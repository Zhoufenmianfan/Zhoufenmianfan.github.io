<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sidian</title>
  
  
  <link href="https://zhoufenmianfan.github.io/atom.xml" rel="self"/>
  
  <link href="https://zhoufenmianfan.github.io/"/>
  <updated>2024-08-12T06:22:29.486Z</updated>
  <id>https://zhoufenmianfan.github.io/</id>
  
  <author>
    <name>H.Z.Y</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>使用Obsidian 发布文章</title>
    <link href="https://zhoufenmianfan.github.io/2024/08/12/Blog-2024-08-12-1143/"/>
    <id>https://zhoufenmianfan.github.io/2024/08/12/Blog-2024-08-12-1143/</id>
    <published>2024-08-12T10:14:52.000Z</published>
    <updated>2024-08-12T06:22:29.486Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用Obsidian-发布文章"><a href="#使用Obsidian-发布文章" class="headerlink" title="使用Obsidian 发布文章"></a>使用Obsidian 发布文章</h2>]]></content>
    
    
    <summary type="html">测试Hexo部署服务</summary>
    
    
    
    <category term="Tech" scheme="https://zhoufenmianfan.github.io/categories/Tech/"/>
    
    
    <category term="Linux" scheme="https://zhoufenmianfan.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>「知识物料」非等长进制数</title>
    <link href="https://zhoufenmianfan.github.io/2024/06/15/%E3%80%8C%E7%9F%A5%E8%AF%86%E7%89%A9%E6%96%99%E3%80%8D%E9%9D%9E%E7%AD%89%E9%95%BF%E8%BF%9B%E5%88%B6%E6%95%B0/"/>
    <id>https://zhoufenmianfan.github.io/2024/06/15/%E3%80%8C%E7%9F%A5%E8%AF%86%E7%89%A9%E6%96%99%E3%80%8D%E9%9D%9E%E7%AD%89%E9%95%BF%E8%BF%9B%E5%88%B6%E6%95%B0/</id>
    <published>2024-06-15T10:14:52.000Z</published>
    <updated>2024-06-15T08:15:46.871Z</updated>
    
    <content type="html"><![CDATA[<h1 id="「知识物料」非等长进制数"><a href="#「知识物料」非等长进制数" class="headerlink" title="「知识物料」非等长进制数"></a>「知识物料」非等长进制数</h1><blockquote><p>废话：这几天在写仿真代码的时候发现的一个应用场景，和数学相关，当然这个问题很简单，也就是数学系的人的课后小作业水平，为了以后可能方便使用于是写了这篇笔记记录一下。</p></blockquote><h2 id="问题定义"><a href="#问题定义" class="headerlink" title="问题定义"></a>问题定义</h2><p>有这样一个进制系统构成的数，“个位”上的进率是 $d_{1}$ ，“十位”上的进率是 $d_{2}$ ，“百位”上的进率是 $d_{3}$ ，“千位”上的进率是 $d_{4}$ ，……称其为 $D$ 进制数。讨论如何将任意一个 $D$ 进制数转化为十进制数，以及如何将任意一个十进制数转化为 $D$ 进制数。</p><p><img src="https://raw.githubusercontent.com/Zhoufenmianfan/images/main/2024A/202406151522743.svg" alt="自定义进制"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>设数位 $x$ 上的进制为 $d_{x}$ ，首先我们需要一套符号体系来表示任意数位 $x$ 上的数值，就像需要 $0\to 9$ 这十个符号去表示十进制各个数位上的数值，定义符号 $S_{0}\to S_{max}$ 来表示 $D$ 进制数中各个数位上的数值。</p><p>数位 $x$ 上的进制为 $d_{x}$ ，就是用前 $d_{x}$ 个符号 $S_{0}\to S_{d_{x}-1}$ 来表示该数位上的数值，需要再进一步增加该位数值时，则向上一位 $d_{x+1}$ 进位。</p><p>那么如何将 $D$ 进制数转十进制就按照上述规则得到公式：</p><p>$$<br>\left( \cdots s_{x} \cdots s_{3}s_{2}s_{1}\right)<em>{D} &#x3D; \left( \cdots +s</em>{x}\times d_{x} + \cdots + s_{3}\times d_{3} + s_{2}\times d_{2} + s_{1}\times d_{1} \right)<em>{10}<br>$$<br>其中，符号 $s</em>{x}$ 表示数位 $x$ 上的数值变量，有 $s_{x}\in \left{ S_{0},\dots,S_{max} \right}$ </p><blockquote><p>[!example] 实例<br><strong>题目</strong>：假设有个三位的 $D$ 进制数，为了表述方便仍然沿用十进制符号 $0\to 9$ ，每个数位上的进率分别为 $d_{3}&#x3D;2,d_{2}&#x3D;5,d_{1}&#x3D;4$ ，转化如下所示的数为十进制数：<br>（1） $(143)<em>{D}$ ；（2） $(22)</em>{D}$<br><strong>解题</strong>：显然有公式<br>（1） $(143)<em>{D} &#x3D; (1\times \left{ 5\times4 \right}+4\times \left{ 4 \right}+3\times \left{ 1 \right})</em>{10}&#x3D;(39)<em>{10}$ ；<br>（2） $(22)</em>{D} &#x3D; (2\times \left{ 4 \right}+2\times \left{ 1 \right})<em>{10}&#x3D;(10)</em>{10}$ </p></blockquote><p>接下来分析如何将十进制数 $(X)<em>{10}$ 转换为 $D$ 进制数。问题的关键在于如何求解出各个数位上的数值 $s</em>{x}$ ，可以从上述过程逆向推理。如果 $x$ 位上计数多一个单位，则必须前 $x-1$ 位都达到满值，即 $d_{x-1}\times d_{x-2}\times \cdots d_{3}\times d_{2}\times d_{1}$ ，要求解数位 $x$ 上的值 $s_{x}$ 则有：</p><p>$$<br>s_{x}&#x3D;\left\lfloor  \frac{(X)<em>{10} }{d</em>{x-1}\times d_{x-2}\times \cdots d_{3}\times d_{2}\times d_{1}}  \right\rfloor<br>$$<br>其中 $\lfloor \cdot \rfloor$ 表示向下取整。再进一步求解下一位 $x-1$ 的数值 $s_{x-1}$  则有：</p><p>$$<br>s_{x-1}&#x3D;\left\lfloor  \frac{(X)<em>{10} \  \text{mod}\  (d</em>{x-1}\times d_{x-2}\times \cdots d_{3}\times d_{2}\times d_{1})}{d_{x-2}\times d_{x-3}\times \cdots d_{3}\times d_{2}\times d_{1}}  \right\rfloor &#x3D;\left\lfloor  \frac{(X)<em>{10} -s</em>{x} \times (d_{x-1}\times d_{x-2}\times \cdots d_{3}\times d_{2}\times d_{1})}{d_{x-2}\times d_{x-3}\times \cdots d_{3}\times d_{2}\times d_{1}}  \right\rfloor<br>$$</p><p>其中 $A\ \text{mod}\ B &#x3D;C$ 表示 $A$ 除以 $B$ 的余数为 $C$ 。依次类推直到求解出所有的数值。</p><blockquote><p>[!example] 实例<br><strong>题目</strong>：假设有个三位的 $D$ 进制数，为了表述方便仍然沿用十进制符号 $0\to 9$ ，每个数位上的进率分别为 $d_{3}&#x3D;2,d_{2}&#x3D;5,d_{1}&#x3D;4$ ，转化如下所示的数为 $D$ 进制数：<br>（1） $(39)<em>{10}$ ；（2） $(10)</em>{10}$<br><strong>解题</strong>：<br>（1）依次求解数位 $x$ 的数值 $s_{x}$ ：<br>当 $x&#x3D;3$ 时：$s_{3}&#x3D;\left\lfloor  \frac{(39)<em>{10} }{5\times 4}  \right\rfloor &#x3D;(1)</em>{D}$ ；<br>当 $x&#x3D;2$ 时：$s_{2}&#x3D;\left\lfloor  \frac{(39)<em>{10}-1\times \left{ 5\times 4 \right} }{4}  \right\rfloor &#x3D;(4)</em>{D}$ ；<br>当 $x&#x3D;1$ 时：$s_{1}&#x3D;\left\lfloor  \frac{(39)<em>{10}-1\times \left{ 5\times 4 \right}-4\times \left{ 4 \right} }{1}  \right\rfloor &#x3D;(3)</em>{D}$ ；<br>于是得到 $(39)<em>{10}&#x3D;(143)</em>{D}$ 。<br>（2）依次求解数位 $x$ 的数值 $s_{x}$ ：<br>当 $x&#x3D;2$ 时：$s_{2}&#x3D;\left\lfloor  \frac{(10)<em>{10} }{4}  \right\rfloor &#x3D;(2)</em>{D}$ ；<br>当 $x&#x3D;1$ 时：$s_{1}&#x3D;\left\lfloor  \frac{(10)<em>{10}-2\times \left{ 4 \right} }{1}  \right\rfloor &#x3D;(2)</em>{D}$ ；<br>于是得到 $(10)<em>{10}&#x3D;(22)</em>{D}$ 。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;「知识物料」非等长进制数&quot;&gt;&lt;a href=&quot;#「知识物料」非等长进制数&quot; class=&quot;headerlink&quot; title=&quot;「知识物料」非等长进制数&quot;&gt;&lt;/a&gt;「知识物料」非等长进制数&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;废话：这几天在写仿真代码的时候发现</summary>
      
    
    
    
    <category term="Know" scheme="https://zhoufenmianfan.github.io/categories/Know/"/>
    
    
    <category term="Math" scheme="https://zhoufenmianfan.github.io/tags/Math/"/>
    
  </entry>
  
  <entry>
    <title>原来：Git可以帮你管理杂乱的不同版本文件</title>
    <link href="https://zhoufenmianfan.github.io/2024/03/10/Git%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E6%95%99%E7%A8%8BPart3/"/>
    <id>https://zhoufenmianfan.github.io/2024/03/10/Git%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E6%95%99%E7%A8%8BPart3/</id>
    <published>2024-03-10T07:56:00.000Z</published>
    <updated>2024-03-10T04:56:44.222Z</updated>
    
    <content type="html"><![CDATA[<p>🚫本教程参照<a href="https://www.liaoxuefeng.com/wiki/896043488029600">廖雪峰的官方网站</a>教程，请优先参考其网站。</p><h2 id="Git优势"><a href="#Git优势" class="headerlink" title="Git优势"></a>Git优势</h2><h3 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h3><p>发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。Git的标签虽然是版本库的快照，但其实它就是指向某个commit的指针（跟分支很像对不对？但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的。</p><p>📌Git有commit，为什么还要引入tag？“请把上周一的那个版本打包发布，commit号是6a5819e…”“一串乱七八糟的数字不好找！”如果换一个办法：“请把上周一的那个版本打包发布，版本号是v1.2”“好的，按照tag v1.2查找commit就行！”所以，tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起。</p><h4 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h4><p>🧊使用命令<code>git tag &lt;name&gt;</code>就可以打一个新标签，默认标签是打在最新提交的commit上的，给过去的commit打标签需要找到历史提交的commit id。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">$ git tag V2.0</span><br><span class="line"></span><br><span class="line">$ git tag</span><br><span class="line">V2.0</span><br><span class="line"></span><br><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line">* efa0d7b (HEAD -&gt; main, tag: V2.0, origin/main) add:add a feature:step11</span><br><span class="line">* df12556 fix rebase</span><br><span class="line">* 5307602 Deev (#2)</span><br><span class="line">* b99d80c add:step10</span><br><span class="line">* bc2c1a8 delete:想想垃圾</span><br><span class="line">*   9059eaa merge with no-ff</span><br><span class="line">|\</span><br><span class="line">| * 7ff15b7 add:merge feature1</span><br><span class="line">|/</span><br><span class="line">*   a86de26 conflick fixed</span><br><span class="line">|\</span><br><span class="line">| * 19d592e add:new a branch feature1</span><br><span class="line">* | 9be30e1 add:Step 7</span><br><span class="line">|/</span><br><span class="line">* 62d62a4 add:new a branch dev</span><br><span class="line">* 241aeea addfile:cancel.txt</span><br><span class="line">* 9c6fad0 add:Step 5</span><br><span class="line">* 674519f add:Step 4</span><br><span class="line">* 6185ab1 add:Step 3; addfile:LICENSE</span><br><span class="line">* a71de4e add:Step 2</span><br><span class="line">* 55fc0ac add:Step 1</span><br><span class="line"></span><br><span class="line">$ git tag V1.0 6185ab1</span><br><span class="line"></span><br><span class="line">$ git tag</span><br><span class="line">V1.0</span><br><span class="line">V2.0</span><br><span class="line"></span><br><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line">* efa0d7b (HEAD -&gt; main, tag: V2.0, origin/main) add:add a feature:step11</span><br><span class="line">* df12556 fix rebase</span><br><span class="line">* 5307602 Deev (#2)</span><br><span class="line">* b99d80c add:step10</span><br><span class="line">* bc2c1a8 delete:想想垃圾</span><br><span class="line">*   9059eaa merge with no-ff</span><br><span class="line">|\</span><br><span class="line">| * 7ff15b7 add:merge feature1</span><br><span class="line">|/</span><br><span class="line">*   a86de26 conflick fixed</span><br><span class="line">|\</span><br><span class="line">| * 19d592e add:new a branch feature1</span><br><span class="line">* | 9be30e1 add:Step 7</span><br><span class="line">|/</span><br><span class="line">* 62d62a4 add:new a branch dev</span><br><span class="line">* 241aeea addfile:cancel.txt</span><br><span class="line">* 9c6fad0 add:Step 5</span><br><span class="line">* 674519f add:Step 4</span><br><span class="line">* 6185ab1 (tag: V1.0) add:Step 3; addfile:LICENSE</span><br><span class="line">* a71de4e add:Step 2</span><br><span class="line">* 55fc0ac add:Step 1</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>🧊使用命令<code>git show &lt;tagname&gt;</code>查看标签信息，标签的作用可以类似于commit id的作用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ git tag show V2.0</span><br><span class="line"></span><br><span class="line">$ git show V2.0</span><br><span class="line">commit efa0d7b0f1ec1f36c8faa2b58d747e58c6f4315b (HEAD -&gt; main, tag: show, tag: V2.0, origin/main)</span><br><span class="line">Author: DESKTOP-SP0MN28\16485 &lt;164854196@qq.com&gt;</span><br><span class="line">Date:   Fri Mar 1 13:38:51 2024 +0800</span><br><span class="line"></span><br><span class="line">    add:add a feature:step11</span><br><span class="line"></span><br><span class="line">diff --git a/readme.txt b/readme.txt</span><br><span class="line">index 44b8501..4e084ff 100644</span><br><span class="line">--- a/readme.txt</span><br><span class="line">+++ b/readme.txt</span><br><span class="line">@@ -11,3 +11,4 @@ step9：工作的部分add到pool了</span><br><span class="line"> step10：工作了一部分，但是还没add到pool</span><br><span class="line"> step11：我自己加了一个功能</span><br><span class="line"> step12：远程小伙加了一个功能</span><br><span class="line">+</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>还可以创建带有说明的标签，用<code>-a</code>指定标签名，<code>-m</code>指定说明文字：</p><h4 id="操作标签"><a href="#操作标签" class="headerlink" title="操作标签"></a>操作标签</h4><p>🧊使用命令<code>git tag -d &lt;tagname&gt;</code>来删除标签<br>🧊使用命令<code>git push origin &lt;tagname&gt;</code>来推送标签到远程<br>🧊使用命令<code>git push origin --tags</code>来一次性推送所有标签到远程</p><h3 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h3><p>有些时候，你必须把某些文件放到Git工作目录中，但又不能提交它们，比如保存了数据库密码的配置文件啦，等等，每次<code>git status</code>都会显示<code>Untracked files ...</code>，有强迫症的童鞋心里肯定不爽。这个问题解决起来也很简单，在Git工作区的根目录下创建一个特殊的<code>.gitignore</code>文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件。不需要从头写<code>.gitignore</code>文件，GitHub已经为我们准备了各种配置文件，只需要组合一下就可以使用了。所有配置文件可以直接在线浏览：<a href="https://github.com/github/gitignore">GitHub&#x2F;gitignore</a></p><h4 id="忽略原则"><a href="#忽略原则" class="headerlink" title="忽略原则"></a>忽略原则</h4><p>忽略文件的原则是：</p><ol><li>忽略操作系统自动生成的文件，比如缩略图等；</li><li>忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的<code>.class</code>文件；</li><li>忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。</li></ol><h4 id="忽略规则"><a href="#忽略规则" class="headerlink" title="忽略规则"></a>忽略规则</h4><p>📌可以通过<a href="https://michaelliao.github.io/gitignore-online-generator/">GitIgnore Online Generator</a>在线生成<code>.gitignore</code>文件并直接下载。</p><p>📌以下所有部分都是在.gitignore中文件写明的规则：</p><p>①假设你在Windows下进行Python开发，Windows会自动在有图片的目录下生成隐藏的缩略图文件，如果有自定义目录，目录下就会有<code>Desktop.ini</code>文件，因此你需要忽略Windows自动生成的垃圾文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Windows:</span><br><span class="line">Thumbs.db</span><br><span class="line">ehthumbs.db</span><br><span class="line">Desktop.ini</span><br></pre></td></tr></table></figure><p>②继续忽略Python编译产生的<code>.pyc</code>、<code>.pyo</code>、<code>dist</code>等文件或目录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># Python:</span><br><span class="line">*.py[cod]</span><br><span class="line">*.so</span><br><span class="line">*.egg</span><br><span class="line">*.egg-info</span><br><span class="line">dist</span><br><span class="line">build</span><br></pre></td></tr></table></figure><p>③加上你自己定义的文件，最终得到一个完整的<code>.gitignore</code>文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># My configurations:</span><br><span class="line">db.ini</span><br><span class="line">deploy_key_rsa</span><br></pre></td></tr></table></figure><p>④例外规则</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 排除所有.开头的隐藏文件:</span><br><span class="line">.*</span><br><span class="line"># 排除所有.class文件:</span><br><span class="line">*.class</span><br><span class="line"></span><br><span class="line"># 不排除.gitignore和App.class:</span><br><span class="line">!.gitignore</span><br><span class="line">!App.class</span><br></pre></td></tr></table></figure><h4 id="文件校验"><a href="#文件校验" class="headerlink" title="文件校验"></a>文件校验</h4><p>最后一步就是把<code>.gitignore</code>也提交到Git，就完成了！当然检验<code>.gitignore</code>的标准是<code>git status</code>命令是不是说<code>working directory clean</code>。</p><p>🧊使用命令<code>git add -f &lt;filename&gt;</code>强制添加被忽略的文件。<br>🧊使用命令<code>git check-ignore</code>命令检查忽略规则。</p><h3 id="配置别名"><a href="#配置别名" class="headerlink" title="配置别名"></a>配置别名</h3><p>只需要敲一行命令，告诉Git，以后<code>st</code>就表示<code>status</code>，当然还有别的命令可以简写，很多人都用<code>co</code>表示<code>checkout</code>，<code>ci</code>表示<code>commit</code>，<code>br</code>表示<code>branch</code>：<code>--global</code>参数是全局参数，也就是这些命令在这台电脑的所有Git仓库下都有用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global alias.co checkout</span><br><span class="line">$ git config --global alias.ci commit</span><br><span class="line">$ git config --global alias.br branch</span><br></pre></td></tr></table></figure><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><p>配置Git的时候，加上<code>--global</code>是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用。配置文件放哪了？每个仓库的Git配置文件都放在<code>.git/config</code>文件中：而当前用户的Git配置文件放在用户主目录下的一个隐藏文件<code>.gitconfig</code>中：</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global alias.lg &quot;log --color --graph --pretty=format:&#x27;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#x27; --abbrev-commit&quot;</span><br></pre></td></tr></table></figure><h2 id="软件平台"><a href="#软件平台" class="headerlink" title="软件平台"></a>软件平台</h2><h3 id="Github开源项目"><a href="#Github开源项目" class="headerlink" title="Github开源项目"></a>Github开源项目</h3><p>在GitHub上，利用Git极其强大的克隆和分支功能，广大人民群众真正可以第一次自由参与各种开源项目了。如何参与一个开源项目呢？比如人气极高的bootstrap项目，这是一个非常强大的CSS框架，你可以访问它的<a href="https://github.com/twbs/bootstrap">项目主页</a>，点“Fork”就在自己的账号下克隆了一个bootstrap仓库，然后，从自己的账号下clone：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:zhoufenmianfan/bootstrap.git</span><br></pre></td></tr></table></figure><p>一定要从自己的账号下clone仓库，这样你才能推送修改。如果从bootstrap的作者的仓库地址<code>git@github.com:twbs/bootstrap.git</code>克隆，因为没有权限，你将不能推送修改。Bootstrap的官方仓库<code>twbs/bootstrap</code>、你在GitHub上克隆的仓库<code>my/bootstrap</code>，以及你自己克隆到本地电脑的仓库，他们的关系就像下图显示的那样：</p><p><img src="https://raw.githubusercontent.com/Zhoufenmianfan/images/main/202403101220513.png"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p><p>如果你想修复bootstrap的一个bug，或者新增一个功能，立刻就可以开始干活，干完后，往自己的仓库推送。如果你希望bootstrap的官方库能接受你的修改，你就可以在GitHub上发起一个pull request。当然，对方是否接受你的pull request就不一定了。</p><h3 id="SourceTree"><a href="#SourceTree" class="headerlink" title="SourceTree"></a>SourceTree</h3><p>当我们对Git的提交、分支已经非常熟悉，可以熟练使用命令操作Git后，再使用GUI工具，就可以更高效。</p><h4 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h4><p>Git有很多图形界面工具，这里我们推荐<a href="https://www.sourcetreeapp.com/">SourceTree</a>，它是由<a href="https://www.atlassian.com/">Atlassian</a>开发的免费Git图形界面工具，可以操作任何Git库。</p><h4 id="软件使用"><a href="#软件使用" class="headerlink" title="软件使用"></a>软件使用</h4><p>第一次运行SourceTree时，SourceTree并不知道我们的Git库在哪。如果本地已经有了Git库，直接从资源管理器把文件夹拖拽到SourceTree上，就添加了一个本地Git库：</p><h3 id="命令手册"><a href="#命令手册" class="headerlink" title="命令手册"></a>命令手册</h3><p>📌手册来源于廖雪峰的官方网站：友情附赠Git Cheat Sheet，建议打印出来备用：<a href="https://liaoxuefeng.gitee.io/resource.liaoxuefeng.com/git/git-cheat-sheet.pdf">Git Cheat Sheet</a></p><p>🔥<a href="https://raw.githubusercontent.com/Zhoufenmianfan/images/main/git-cheat-sheet.pdf">Git命令手册下载</a></p>]]></content>
    
    
    <summary type="html">Git是什么？Github和它一样吗？</summary>
    
    
    
    <category term="Tech" scheme="https://zhoufenmianfan.github.io/categories/Tech/"/>
    
    
    <category term="Computer" scheme="https://zhoufenmianfan.github.io/tags/Computer/"/>
    
    <category term="Git" scheme="https://zhoufenmianfan.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>原来：Git可以帮你管理杂乱的不同版本文件</title>
    <link href="https://zhoufenmianfan.github.io/2024/02/29/Git%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E6%95%99%E7%A8%8BPart2/"/>
    <id>https://zhoufenmianfan.github.io/2024/02/29/Git%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E6%95%99%E7%A8%8BPart2/</id>
    <published>2024-02-29T07:56:00.000Z</published>
    <updated>2024-03-10T04:56:42.642Z</updated>
    
    <content type="html"><![CDATA[<p>🚫本教程参照<a href="https://www.liaoxuefeng.com/wiki/896043488029600">廖雪峰的官方网站</a>教程，请优先参考其网站。</p><h2 id="Git优势"><a href="#Git优势" class="headerlink" title="Git优势"></a>Git优势</h2><h3 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h3><p>Git是分布式版本控制系统，同一个Git仓库，可以分布到不同的机器上。怎么分布呢？最早，肯定只有一台机器有一个原始版本库，此后，别的机器可以“克隆”这个原始版本库，而且每台机器的版本库其实都是一样的，并没有主次之分。实际情况往往是这样，找一台电脑充当服务器的角色，每天24小时开机，其他每个人都从这个“服务器”仓库克隆一份到自己的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交。完全可以自己搭建一台运行Git的服务器，不过现阶段，为了学Git先搭个服务器绝对是小题大作。好在这个世界上有个叫<a href="https://github.com/">GitHub</a>的神奇的网站，从名字就可以看出，这个网站就是提供Git仓库托管服务的，所以，只要注册一个GitHub账号，就可以免费获得Git远程仓库。</p><h4 id="Github远程仓库"><a href="#Github远程仓库" class="headerlink" title="Github远程仓库"></a>Github远程仓库</h4><p>请直接去<a href="https://github.com/">Github官网</a>注册一个账户。</p><h4 id="Github-SSH-key设置"><a href="#Github-SSH-key设置" class="headerlink" title="Github SSH key设置"></a>Github SSH key设置</h4><p>📌以下内容略写，请查阅相关其他资料</p><ul><li>第1步：创建SSH Key。</li><li>第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面：然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴<code>id_rsa.pub</code>文件的内容：</li></ul><p>为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。</p><p>当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。</p><h4 id="Github仓库推送"><a href="#Github仓库推送" class="headerlink" title="Github仓库推送"></a>Github仓库推送</h4><p>按照Github提示执行指令将本地的仓库代码推送到Github，添加后，远程库的名字就是<code>origin</code>，这是Git默认的叫法，也可以改成别的，但是<code>origin</code>这个名字一看就知道是远程库。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:Zhoufenmianfan/GitStudy.git</span><br><span class="line">git branch -M main</span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git push -u origin main</span><br><span class="line">Enumerating objects: 20, done.</span><br><span class="line">Counting objects: 100% (20/20), done.</span><br><span class="line">Delta compression using up to 16 threads</span><br><span class="line">Compressing objects: 100% (17/17), done.</span><br><span class="line">Writing objects: 100% (20/20), 2.14 KiB | 2.14 MiB/s, done.</span><br><span class="line">Total 20 (delta 7), reused 0 (delta 0), pack-reused 0</span><br><span class="line">remote: Resolving deltas: 100% (7/7), done.</span><br><span class="line">To github.com:Zhoufenmianfan/GitStudy.git</span><br><span class="line"> * [new branch]      main -&gt; main</span><br><span class="line">branch &#x27;main&#x27; set up to track &#x27;origin/main&#x27;.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>📌由于远程库是空的，我们第一次推送<code>main</code>分支时，加上了<code>-u</code>参数，Git不但会把本地的<code>main</code>分支内容推送的远程新的<code>main</code>分支，还会把本地的<code>main</code>分支和远程的<code>main</code>分支关联起来，在以后的推送或者拉取时就可以简化命令。</p><h4 id="Github仓库绑定解除"><a href="#Github仓库绑定解除" class="headerlink" title="Github仓库绑定解除"></a>Github仓库绑定解除</h4><p>想解除本地与远程仓库的连接，可以用<code>git remote rm &lt;name&gt;</code>命令。使用前，建议先用<code>git remote -v</code>查看远程库信息，这里的<code>rm</code>是解除了本地和远程的绑定关系，并不是物理上删除了远程库。远程库本身并没有任何改动。要真正删除远程库，需要登录到GitHub，在后台页面找到删除按钮再删除。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin  git@github.com:Zhoufenmianfan/GitStudy.git (fetch)</span><br><span class="line">origin  git@github.com:Zhoufenmianfan/GitStudy.git (push)</span><br><span class="line"></span><br><span class="line">$ git remote rm origin</span><br><span class="line"></span><br><span class="line">$ git remote -v</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="远程库克隆"><a href="#远程库克隆" class="headerlink" title="远程库克隆"></a>远程库克隆</h4><p>假设我们从零开发，那么最好的方式是先创建远程库，然后，从远程库克隆。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git clone git@github.com:Zhoufenmianfan/Zhoufenmianfan.github.io.git</span><br><span class="line">Cloning into &#x27;Zhoufenmianfan.github.io&#x27;...</span><br><span class="line">remote: Enumerating objects: 570, done.</span><br><span class="line">remote: Counting objects: 100% (569/569), done.</span><br><span class="line">remote: Compressing objects: 100% (187/187), done.</span><br><span class="line">remote: Total 570 (delta 241), reused 560 (delta 232), pack-reused 1</span><br><span class="line">Receiving objects: 100% (570/570), 3.38 MiB | 1.99 MiB/s, done.</span><br><span class="line">Resolving deltas: 100% (241/241), done.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>📌GitHub给出的地址不止一个，还可以用<code>https://github.com/michaelliao/gitskills.git</code>这样的地址。实际上，Git支持多种协议，默认的<code>git://</code>使用ssh，但也可以使用<code>https</code>等其他协议。使用<code>https</code>除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用<code>ssh</code>协议而只能用<code>https</code>。</p><h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><p>分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。</p><h4 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h4><p>在版本回退里，你已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即<code>master</code>分支。<code>HEAD</code>严格来说不是指向提交，而是指向<code>master</code>，<code>master</code>才是指向提交的，所以，<code>HEAD</code>指向的就是当前分支。一开始的时候，<code>master</code>分支是一条线，Git用<code>master</code>指向最新的提交，再用<code>HEAD</code>指向<code>master</code>，就能确定当前分支，以及当前分支的提交点。每次提交，<code>master</code>分支都会向前移动一步，这样，随着你不断提交，<code>master</code>分支的线也越来越长。</p><p><img src="https://raw.githubusercontent.com/Zhoufenmianfan/images/main/202402292120238.png"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p><p>当我们创建新的分支，例如<code>dev</code>时，Git新建了一个指针叫<code>dev</code>，指向<code>master</code>相同的提交，再把<code>HEAD</code>指向<code>dev</code>，就表示当前分支在<code>dev</code>上：<br><img src="https://raw.githubusercontent.com/Zhoufenmianfan/images/main/202402292121588.png"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p><p>从现在开始，对工作区的修改和提交就是针对<code>dev</code>分支了，比如新提交一次后，<code>dev</code>指针往前移动一步，而<code>master</code>指针不变：</p><p><img src="https://raw.githubusercontent.com/Zhoufenmianfan/images/main/202402292122740.png"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p><p>假如我们在<code>dev</code>上的工作完成了，就可以把<code>dev</code>合并到<code>master</code>上。Git怎么合并呢？最简单的方法，就是直接把<code>master</code>指向<code>dev</code>的当前提交，就完成了合并：</p><p><img src="https://raw.githubusercontent.com/Zhoufenmianfan/images/main/202402292123282.png"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p><p>合并完分支后，甚至可以删除<code>dev</code>分支。删除<code>dev</code>分支就是把<code>dev</code>指针给删掉，删掉后，我们就剩下了一条<code>master</code>分支：</p><p><img src="https://raw.githubusercontent.com/Zhoufenmianfan/images/main/202402292124199.png"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p><h4 id="分支创建"><a href="#分支创建" class="headerlink" title="分支创建"></a>分支创建</h4><p>🧊使用命令<code>git branch</code>来创建一个分支，使用命令<code>git checkout</code>或者<code>git switch</code>可以切换到任意一个分支，或者使用合并的命令<code>git checkout -b</code>或者<code>git switch -c</code>来创建并切换到新创建的分支</p><p>🧊使用命令<code>git branch</code>还可以查看当前分支，<code>git branch</code>命令会列出所有分支，当前分支前面会标一个<code>*</code>号。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b dev</span><br><span class="line">Switched to a new branch &#x27;dev&#x27;</span><br><span class="line"></span><br><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  main</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在<code>dev</code>分支上正常提交，比如对<code>readme.txt</code>做个修改，加上一行内容再add再commit</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout dev</span><br><span class="line">Switched to branch &#x27;dev&#x27;</span><br><span class="line"></span><br><span class="line">$ git add readme.txt</span><br><span class="line"></span><br><span class="line">$ git commit -m &quot;add:new a branch dev&quot;</span><br><span class="line">[dev 62d62a4] add:new a branch dev</span><br><span class="line"> 1 file changed, 2 insertions(+), 1 deletion(-)</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="分支切换"><a href="#分支切换" class="headerlink" title="分支切换"></a>分支切换</h4><p>现在，<code>dev</code>分支的工作完成，我们就可以切换回<code>main</code>分支，由于一些特殊原因，Github提倡使用<code>main</code>分支名称，而不再使用<code>master</code>，因此现在已经没有<code>master</code>分支了，取而代之为<code>main</code>分支：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt</span><br><span class="line"></span><br><span class="line">$ git commit -m &quot;add:new a branch dev&quot;</span><br><span class="line">[dev 62d62a4] add:new a branch dev</span><br><span class="line"> 1 file changed, 2 insertions(+), 1 deletion(-)</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line"></span><br><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  main</span><br><span class="line"></span><br><span class="line">$ git checkout main</span><br><span class="line">Switched to branch &#x27;main&#x27;</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch main</span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>切换回<code>main</code>分支后，再查看一个<code>readme.txt</code>文件，刚才添加的内容不见了！因为那个提交是在<code>dev</code>分支上，而<code>main</code>分支此刻的提交点并没有变：我们注意到切换分支使用<code>git checkout &lt;branch&gt;</code>，而前面讲过的撤销修改则是<code>git checkout -- &lt;file&gt;</code>，同一个命令，有两种作用，确实有点令人迷惑。实际上，切换分支这个动作，用<code>switch</code>更科学。因此，最新版本的Git提供了新的<code>git switch</code>命令来切换分支。</p><h4 id="分支合并"><a href="#分支合并" class="headerlink" title="分支合并"></a>分支合并</h4><p>🧊使用命令<code>git merge</code>用于合并指定分支到当前分支。现在，我们把<code>dev</code>分支的工作成果合并到<code>master</code>分支上，注意到上面的<code>Fast-forward</code>信息，Git告诉我们，这次合并是“快进模式”，也就是直接把<code>master</code>指向<code>dev</code>的当前提交，所以合并速度非常快。当然，也不是每次合并都能<code>Fast-forward</code>，我们后面会讲其他方式的合并。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git merge dev</span><br><span class="line">Updating 241aeea..62d62a4</span><br><span class="line">Fast-forward</span><br><span class="line"> readme.txt | 3 ++-</span><br><span class="line"> 1 file changed, 2 insertions(+), 1 deletion(-)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="分支删除"><a href="#分支删除" class="headerlink" title="分支删除"></a>分支删除</h4><p>合并完成后，就可以放心地删除<code>dev</code>分支了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d dev</span><br><span class="line">Deleted branch dev (was 62d62a4).</span><br><span class="line"></span><br><span class="line">$ git branch</span><br><span class="line">* main</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="分支冲突"><a href="#分支冲突" class="headerlink" title="分支冲突"></a>分支冲突</h4><p>首先看这样一种分支冲突情况：</p><ul><li>第①步：一个分支为<code>feature1</code>分支，添加内容后add+commit；</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* main</span><br><span class="line"></span><br><span class="line">$ git switch -c feature1</span><br><span class="line">Switched to a new branch &#x27;feature1&#x27;</span><br><span class="line"></span><br><span class="line">$ git add readme.txt</span><br><span class="line"></span><br><span class="line">$ git commit -m &quot;add:new a branch feature1&quot;</span><br><span class="line">[feature1 19d592e] add:new a branch feature1</span><br><span class="line"> 1 file changed, 3 insertions(+), 1 deletion(-)</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>第②步：切换到<code>main</code>分支，修改内容，add+commit；</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git switch main</span><br><span class="line">Switched to branch &#x27;main&#x27;</span><br><span class="line"></span><br><span class="line">$ git add readme.txt</span><br><span class="line"></span><br><span class="line">$ git commit -m &quot;add:Step 7&quot;</span><br><span class="line">[main 9be30e1] add:Step 7</span><br><span class="line"> 1 file changed, 3 insertions(+), 1 deletion(-)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>现在，<code>main</code>分支和<code>feature1</code>分支各自都分别有新的提交，变成了这样：</p><p><img src="https://raw.githubusercontent.com/Zhoufenmianfan/images/main/202402292155548.png"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p><p>这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ git merge feature1</span><br><span class="line">Auto-merging readme.txt</span><br><span class="line">CONFLICT (content): Merge conflict in readme.txt</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch main</span><br><span class="line">You have unmerged paths.</span><br><span class="line">  (fix conflicts and run &quot;git commit&quot;)</span><br><span class="line">  (use &quot;git merge --abort&quot; to abort the merge)</span><br><span class="line"></span><br><span class="line">Unmerged paths:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to mark resolution)</span><br><span class="line">        both modified:   readme.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>🧊使用命令<code>git diff</code>可以查看差异，<code>++&lt;&lt;&lt;&lt;&lt;&lt;&lt; ======= &gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>用来区分不同的分支内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ git diff</span><br><span class="line">diff --cc readme.txt</span><br><span class="line">index 9c77a4d,214bcb7..0000000</span><br><span class="line">--- a/readme.txt</span><br><span class="line">+++ b/readme.txt</span><br><span class="line">@@@ -6,4 -6,4 +6,8 @@@ step4：自定义修改文件内容，&lt;E4&gt;</span><br><span class="line">  step5：🧊使用命令`git status`查看当前仓库内的文件和上一次commit操作后的文件差</span><br><span class="line">异，提示在主分支`On branch master`被修改过了，`Changes not staged for commit:`但还没有准备提交的修改文件`modified:   readme.txt`，推荐你使用命令`git add &lt;file&gt;`去将这个文件添加到pool中以备后续commit，或者使用命令`git restore &lt;file&gt;`去忽略这部分改动。`no changes added to commit`没有新的通过add文件到pool中去用于commit。</span><br><span class="line">  step6：创建一个新的分支dev</span><br><span class="line"></span><br><span class="line">- step7：直接在main上修改文件</span><br><span class="line"> -step7：创建一个新的分支feature1</span><br><span class="line">++&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">++step7：直接在main上修改文件</span><br><span class="line">++=======</span><br><span class="line">++step7：创建一个新的分支feature1</span><br><span class="line">++&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>观察抉择后，决定仍然使用<code>main</code>分支的内容，或者也可以主动观察<code>feature1</code>分支内容，对<code>main</code>进行修改后，再add+commit。</p><p>🧊使用命令<code>git log --graph --pretty=oneline --abbrev-commit</code>可以查看分支图日志</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt</span><br><span class="line"></span><br><span class="line">(main|MERGING)</span><br><span class="line">$ git commit -m &quot;conflick fixed&quot;</span><br><span class="line">[main a86de26] conflick fixed</span><br><span class="line"></span><br><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line">*   a86de26 (HEAD -&gt; main) conflick fixed</span><br><span class="line">|\</span><br><span class="line">| * 19d592e (feature1) add:new a branch feature1</span><br><span class="line">* | 9be30e1 add:Step 7</span><br><span class="line">|/</span><br><span class="line">* 62d62a4 add:new a branch dev</span><br><span class="line">* 241aeea addfile:cancel.txt</span><br><span class="line">* 9c6fad0 add:Step 5</span><br><span class="line">* 674519f add:Step 4</span><br><span class="line">* 6185ab1 add:Step 3; addfile:LICENSE</span><br><span class="line">* a71de4e add:Step 2</span><br><span class="line">* 55fc0ac add:Step 1</span><br><span class="line"></span><br><span class="line">$ git branch</span><br><span class="line">  feature1</span><br><span class="line">* main</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>现在，<code>master</code>分支和<code>feature1</code>分支变成了下图所示，如果不需要<code>feature1</code>分支了，就可以删除了。<br><img src="https://raw.githubusercontent.com/Zhoufenmianfan/images/main/202402292213020.png"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d feature1</span><br><span class="line">Deleted branch feature1 (was 19d592e).</span><br><span class="line"></span><br><span class="line">$ git branch</span><br><span class="line">* main</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="分支策略"><a href="#分支策略" class="headerlink" title="分支策略"></a>分支策略</h4><p>通常，合并分支时，如果可能，Git会用<code>Fast forward</code>模式，但这种模式下，删除分支后，会丢掉分支信息。如果要强制禁用<code>Fast forward</code>模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。</p><p>首先，仍然创建并切换<code>deev</code>分支，修改readme.txt文件，并提交一个新的commit，切换回<code>main</code>，准备合并<code>dev</code>分支，请注意<code>--no-ff</code>参数，表示禁用<code>Fast forward</code>，因为本次合并要创建一个新的commit，所以加上<code>-m</code>参数，把commit描述写进去。合并后，我们用<code>git log</code>看看分支历史。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">$ git switch -c deev</span><br><span class="line">Switched to a new branch &#x27;deev&#x27;</span><br><span class="line"></span><br><span class="line">$ git add readme.txt</span><br><span class="line"></span><br><span class="line">$ git commit -m &quot;add:merge feature1&quot;</span><br><span class="line">[deev 7ff15b7] add:merge feature1</span><br><span class="line"> 1 file changed, 2 insertions(+), 5 deletions(-)</span><br><span class="line"></span><br><span class="line">$ git switch main</span><br><span class="line">Switched to branch &#x27;main&#x27;</span><br><span class="line"></span><br><span class="line">$ git merge --no-ff -m &quot;merge with no-ff&quot; deev</span><br><span class="line">Merge made by the &#x27;ort&#x27; strategy.</span><br><span class="line"> readme.txt | 7 ++-----</span><br><span class="line"> 1 file changed, 2 insertions(+), 5 deletions(-)</span><br><span class="line"></span><br><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line">*   9059eaa (HEAD -&gt; main) merge with no-ff</span><br><span class="line">|\</span><br><span class="line">| * 7ff15b7 (deev) add:merge feature1</span><br><span class="line">|/</span><br><span class="line">*   a86de26 conflick fixed</span><br><span class="line">|\</span><br><span class="line">| * 19d592e add:new a branch feature1</span><br><span class="line">* | 9be30e1 add:Step 7</span><br><span class="line">|/</span><br><span class="line">* 62d62a4 add:new a branch dev</span><br><span class="line">* 241aeea addfile:cancel.txt</span><br><span class="line">* 9c6fad0 add:Step 5</span><br><span class="line">* 674519f add:Step 4</span><br><span class="line">* 6185ab1 add:Step 3; addfile:LICENSE</span><br><span class="line">* a71de4e add:Step 2</span><br><span class="line">* 55fc0ac add:Step 1</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到，不使用<code>Fast forward</code>模式，merge后就像这样：</p><p><img src="https://raw.githubusercontent.com/Zhoufenmianfan/images/main/202402292223138.png"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p><p>在实际开发中，我们应该按照几个基本原则进行分支管理：</p><ul><li><p>首先，<code>master</code>分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；</p></li><li><p>其次，干活都在<code>dev</code>分支上，也就是说，<code>dev</code>分支是不稳定的，到某个时候，比如1.0版本发布时，再把<code>dev</code>分支合并到<code>master</code>上，在<code>master</code>分支发布1.0版本；你和你的小伙伴们每个人都在<code>dev</code>分支上干活，每个人都有自己的分支，时不时地往<code>dev</code>分支上合并就可以了。</p></li></ul><p>所以，团队合作的分支看起来就像这样：</p><p><img src="https://raw.githubusercontent.com/Zhoufenmianfan/images/main/202402292225350.png"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p><h4 id="BUG分支"><a href="#BUG分支" class="headerlink" title="BUG分支"></a>BUG分支</h4><p>场景：软件开发中，bug就像家常便饭一样。有了bug就需要修复，在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支<code>issue-101</code>来修复它，但是，等等，当前正在<code>dev</code>上进行的工作还没有提交，Git还提供了一个<code>stash</code>功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch main</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage)</span><br><span class="line">        modified:   readme.txt</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line">        modified:   readme.txt</span><br><span class="line"></span><br><span class="line">$ git diff</span><br><span class="line">diff --git a/readme.txt b/readme.txt</span><br><span class="line">index 3a7f95c..e7dfc56 100644</span><br><span class="line">--- a/readme.txt</span><br><span class="line">+++ b/readme.txt</span><br><span class="line">@@ -8,5 +8,5 @@ step6：创建一个新的分支dev</span><br><span class="line"> step7：创建一个新的分支feature1，想想垃圾，还是直接在main上修改文件</span><br><span class="line"> step8：分支管理</span><br><span class="line"> step9：工作的部分add到pool了</span><br><span class="line">-</span><br><span class="line">+step10：工作了一部分，但是还没add到pool</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>🧊使用命令<code>git stash</code>将现在的工作区先存储起来。现在，用<code>git status</code>查看工作区，就是干净的（除非有没有被Git管理的文件），因此可以放心地创建分支来修复bug。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git stash</span><br><span class="line">Saved working directory and index state WIP on main: 9059eaa merge with no-ff</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch main</span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>首先确定要在哪个分支上修复bug，假定需要在<code>main</code>分支上修复，就从<code>main</code>创建临时分支：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git switch -c issue-101</span><br><span class="line">Switched to a new branch &#x27;issue-101&#x27;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后修复了Bug，add+commit，再切换到<code>main</code>分支，并完成合并，最后删除<code>issue-101</code>分支：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt</span><br><span class="line"></span><br><span class="line">$ git commit -m &quot;delete:想想垃圾&quot;</span><br><span class="line">[issue-101 bc2c1a8] delete:想想垃圾</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br><span class="line"></span><br><span class="line">$ git switch main</span><br><span class="line">Switched to branch &#x27;main&#x27;</span><br><span class="line"></span><br><span class="line">$ git merge issue-101</span><br><span class="line">Updating 9059eaa..bc2c1a8</span><br><span class="line">Fast-forward</span><br><span class="line"> readme.txt | 2 +-</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br><span class="line"></span><br><span class="line">$ git branch -d issue-101</span><br><span class="line">Deleted branch issue-101 (was bc2c1a8).</span><br><span class="line"></span><br><span class="line">$ git branch</span><br><span class="line">  deev</span><br><span class="line">* main</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>想要继续干活，查看一下工作区状态，工作区是干净的，</p><p>🧊用<code>git stash list</code>命令查看，工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法：一是用<code>git stash apply</code>恢复，但是恢复后，stash内容并不删除，你需要用<code>git stash drop</code>来删除；另一种方式是用<code>git stash pop</code>，恢复的同时把stash内容也删了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch main</span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line"></span><br><span class="line">$ git stash list</span><br><span class="line">stash@&#123;0&#125;: WIP on main: 9059eaa merge with no-ff</span><br><span class="line"></span><br><span class="line">$ git stash pop</span><br><span class="line">Auto-merging readme.txt</span><br><span class="line">On branch main</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line">        modified:   readme.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br><span class="line">Dropped refs/stash@&#123;0&#125; (57e1c819b0b2264c33710b1f0ef9141c1a358305)</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch main</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line">        modified:   readme.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>同时我们发现，刚刚在开发时，我们一直在<code>main</code>分支上，并且在修bug前已经有一部分内容add到pool了，这时我们在修完bug后，commit提交的过程中，不只是把bug内容提交了，同样也把之前开发的add到pool中的内容也提交了，所以现在恢复的工作区的显示的status中只剩下了待add+commit的内容了。所以开发一定要记得在dev分支上！</p><p>再用<code>git stash list</code>查看，就看不到任何stash内容了，你可以多次stash，恢复的时候，先用<code>git stash list</code>查看，然后恢复指定的stash，用命令<code>git stash apply stash@&#123;0&#125;</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git stash list</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在<code>main</code>分支上修复了bug后，我们要想一想，dev分支是早期从<code>main</code>分支分出来的，所以，这个bug其实在当前dev分支上也存在。那怎么在dev分支上修复同样的bug？重复操作一次，提交不就行了？同样的bug，要在dev上修复，我们只需要把<code>4c805e2 fix bug 101</code>这个提交所做的修改“复制”到dev分支。注意：我们只想复制<code>4c805e2 fix bug 101</code>这个提交所做的修改，并不是把整个<code>main</code>分支merge过来。</p><p>🧊使用命令<code>git cherry-pick</code>可以将指定的提交复制到当前分支上，这里由于我们是在main分支上开发的，所以已经不能直接复制bug那个提交了，我们复制了另一次切换分支前的提交。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$ git cherry-pick 4c805e2</span><br><span class="line">fatal: bad revision &#x27;4c805e2&#x27;</span><br><span class="line"></span><br><span class="line">$ git cherry-pick b99d80c</span><br><span class="line">Auto-merging readme.txt</span><br><span class="line">[deev ba2eadf] add:step10</span><br><span class="line"> Date: Thu Feb 29 22:49:00 2024 +0800</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br><span class="line"></span><br><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line">* ba2eadf (HEAD -&gt; deev) add:step10</span><br><span class="line">* 7ff15b7 add:merge feature1</span><br><span class="line">*   a86de26 conflick fixed</span><br><span class="line">|\</span><br><span class="line">| * 19d592e add:new a branch feature1</span><br><span class="line">* | 9be30e1 add:Step 7</span><br><span class="line">|/</span><br><span class="line">* 62d62a4 add:new a branch dev</span><br><span class="line">* 241aeea addfile:cancel.txt</span><br><span class="line">* 9c6fad0 add:Step 5</span><br><span class="line">* 674519f add:Step 4</span><br><span class="line">* 6185ab1 add:Step 3; addfile:LICENSE</span><br><span class="line">* a71de4e add:Step 2</span><br><span class="line">* 55fc0ac add:Step 1</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ git switch main</span><br><span class="line">Switched to branch &#x27;main&#x27;</span><br><span class="line"></span><br><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line">* b99d80c (HEAD -&gt; main) add:step10</span><br><span class="line">* bc2c1a8 delete:想想垃圾</span><br><span class="line">*   9059eaa merge with no-ff</span><br><span class="line">|\</span><br><span class="line">| * 7ff15b7 add:merge feature1</span><br><span class="line">|/</span><br><span class="line">*   a86de26 conflick fixed</span><br><span class="line">|\</span><br><span class="line">| * 19d592e add:new a branch feature1</span><br><span class="line">* | 9be30e1 add:Step 7</span><br><span class="line">|/</span><br><span class="line">* 62d62a4 add:new a branch dev</span><br><span class="line">* 241aeea addfile:cancel.txt</span><br><span class="line">* 9c6fad0 add:Step 5</span><br><span class="line">* 674519f add:Step 4</span><br><span class="line">* 6185ab1 add:Step 3; addfile:LICENSE</span><br><span class="line">* a71de4e add:Step 2</span><br><span class="line">* 55fc0ac add:Step 1</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>既然可以在<code>main</code>分支上修复bug后，在dev分支上可以“重放”这个修复过程，那么直接在dev分支上修复bug，然后在<code>main</code>分支上“重放”行不行？当然可以，不过你仍然需要<code>git stash</code>命令保存现场，才能从dev分支切换到<code>main</code>分支。</p><h4 id="功能分支"><a href="#功能分支" class="headerlink" title="功能分支"></a>功能分支</h4><p>添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。于是和bug分支一样，不过是issue是main的分支，而feature是dev的分支。一切顺利的话，feature分支和bug分支是类似的，合并，然后删除。</p><p>但是如果还没有合并到dev分支上，就需要停止开发，就需要强行删除feature分支。如果直接删除则会销毁失败。Git友情提醒，<code>feature-vulcan</code>分支还没有被合并，如果删除，将丢失掉修改，如果要强行删除，需要使用大写的<code>-D</code>参数。</p><p>🧊使用命令<code>git branch -D</code>来强行删除分支</p><h3 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h3><p>当你从远程仓库克隆时，实际上Git自动把本地的<code>master</code>分支和远程的<code>master</code>分支对应起来了，并且，远程仓库的默认名称是<code>origin</code>。</p><p>🧊使用命令<code>git remote</code>查看远程库的信息，或者，用<code>git remote -v</code>显示更详细的信息，上面显示了可以抓取和推送的<code>origin</code>的地址。如果没有推送权限，就看不到push的地址。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin  git@github.com:Zhoufenmianfan/Zhoufenmianfan.github.io.git (fetch)</span><br><span class="line">origin  git@github.com:Zhoufenmianfan/Zhoufenmianfan.github.io.git (push)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="推送分支"><a href="#推送分支" class="headerlink" title="推送分支"></a>推送分支</h4><p>🧊使用命令<code>git push</code>来推送指定分支到有权限的关联远程库，推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上，如果要推送其他分支，比如<code>dev</code>，就改成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin deev</span><br><span class="line">Enumerating objects: 5, done.</span><br><span class="line">Counting objects: 100% (5/5), done.</span><br><span class="line">Delta compression using up to 16 threads</span><br><span class="line">Compressing objects: 100% (3/3), done.</span><br><span class="line">Writing objects: 100% (3/3), 369 bytes | 369.00 KiB/s, done.</span><br><span class="line">Total 3 (delta 2), reused 0 (delta 0), pack-reused 0</span><br><span class="line">remote: Resolving deltas: 100% (2/2), completed with 2 local objects.</span><br><span class="line">remote:</span><br><span class="line">remote: Create a pull request for &#x27;deev&#x27; on GitHub by visiting:</span><br><span class="line">remote:      https://github.com/Zhoufenmianfan/GitStudy/pull/new/deev</span><br><span class="line">remote:</span><br><span class="line">To github.com:Zhoufenmianfan/GitStudy.git</span><br><span class="line"> * [new branch]      deev -&gt; deev</span><br><span class="line"></span><br><span class="line">$ git push origin main</span><br><span class="line">Enumerating objects: 24, done.</span><br><span class="line">Counting objects: 100% (24/24), done.</span><br><span class="line">Delta compression using up to 16 threads</span><br><span class="line">Compressing objects: 100% (22/22), done.</span><br><span class="line">Writing objects: 100% (22/22), 2.04 KiB | 2.04 MiB/s, done.</span><br><span class="line">Total 22 (delta 16), reused 0 (delta 0), pack-reused 0</span><br><span class="line">remote: Resolving deltas: 100% (16/16), completed with 2 local objects.</span><br><span class="line">To github.com:Zhoufenmianfan/GitStudy.git</span><br><span class="line">   241aeea..b99d80c  main -&gt; main</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？</p><ul><li><p><code>master</code>分支是主分支，因此要时刻与远程同步；</p></li><li><p><code>dev</code>分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</p></li><li><p>bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；</p></li><li><p>feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</p></li></ul><p>总之，就是在Git中，分支完全可以在本地自己藏着玩，是否推送，视你的心情而定！</p><p>多人协作的工作模式通常是这样：</p><ol><li><p>首先，可以试图用<code>git push origin &lt;branch-name&gt;</code>推送自己的修改；</p></li><li><p>如果推送失败，则因为远程分支比你的本地更新，需要先用<code>git pull</code>试图合并；</p></li><li><p>如果合并有冲突，则解决冲突，并在本地提交；</p></li><li><p>没有冲突或者解决掉冲突后，再用<code>git push origin &lt;branch-name&gt;</code>推送就能成功！</p></li></ol><h4 id="抓取分支"><a href="#抓取分支" class="headerlink" title="抓取分支"></a>抓取分支</h4><p>多人协作时，大家都会往<code>master</code>和<code>dev</code>分支上推送各自的修改。现在，模拟一个你的小伙伴，可以在另一台电脑（注意要把SSH Key添加到GitHub）或者同一台电脑的另一个目录下克隆。默认情况下，你的小伙伴只能看到本地的<code>master</code>分支。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ git clone git@github.com:Zhoufenmianfan/GitStudy.git</span><br><span class="line">Cloning into &#x27;GitStudy&#x27;...</span><br><span class="line">remote: Enumerating objects: 42, done.</span><br><span class="line">remote: Counting objects: 100% (42/42), done.</span><br><span class="line">remote: Compressing objects: 100% (16/16), done.</span><br><span class="line">Receiving objects: 100% (42/42), 4.02 KiB | 4.02 MiB/s, done.</span><br><span class="line">remote: Total 42 (delta 23), reused 42 (delta 23), pack-reused 0</span><br><span class="line">Resolving deltas: 100% (23/23), done.</span><br><span class="line"></span><br><span class="line">$ cd GitStudy/</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch main</span><br><span class="line">Your branch is up to date with &#x27;origin/main&#x27;.</span><br><span class="line"></span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line"></span><br><span class="line">$ git branch</span><br><span class="line">* main</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果远程重新创建了一个分支，那么需要使用pull命令重新拉取一遍远程库的内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git pull</span><br><span class="line">remote: Enumerating objects: 5, done.</span><br><span class="line">remote: Counting objects: 100% (5/5), done.</span><br><span class="line">remote: Compressing objects: 100% (1/1), done.</span><br><span class="line">remote: Total 3 (delta 2), reused 3 (delta 2), pack-reused 0</span><br><span class="line">Unpacking objects: 100% (3/3), 349 bytes | 0 bytes/s, done.</span><br><span class="line">From github.com:Zhoufenmianfan/GitStudy</span><br><span class="line"> * [new branch]      deev       -&gt; origin/deev</span><br><span class="line">Already up to date.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>🧊使用命令<code>git checkout -b &lt;本地分支&gt; &lt;远程分支&gt;</code>可以将远程分支创建到本地</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* main</span><br><span class="line"></span><br><span class="line">$ git checkout -b deev origin/deev</span><br><span class="line">Switched to a new branch &#x27;deev&#x27;</span><br><span class="line">branch &#x27;deev&#x27; set up to track &#x27;origin/deev&#x27;.</span><br><span class="line"></span><br><span class="line">$ git branch</span><br><span class="line">* deev</span><br><span class="line">  main</span><br></pre></td></tr></table></figure><p>小伙伴开发了一下功能，add+commit到他本地的deev后，push到了我们共同的远程库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* deev</span><br><span class="line">  main</span><br><span class="line"></span><br><span class="line">$ git add readme.txt</span><br><span class="line"></span><br><span class="line">$ git commit -m &quot;add:add a feature:step11&quot;</span><br><span class="line">[deev 610e6ac] add:add a feature:step11</span><br><span class="line"> 1 file changed, 2 insertions(+), 1 deletion(-)</span><br><span class="line"></span><br><span class="line">$ git push origin deev</span><br><span class="line">Enumerating objects: 5, done.</span><br><span class="line">Counting objects: 100% (5/5), done.</span><br><span class="line">Delta compression using up to 16 threads</span><br><span class="line">Compressing objects: 100% (3/3), done.</span><br><span class="line">Writing objects: 100% (3/3), 379 bytes | 379.00 KiB/s, done.</span><br><span class="line">Total 3 (delta 2), reused 0 (delta 0), pack-reused 0</span><br><span class="line">remote: Resolving deltas: 100% (2/2), completed with 2 local objects.</span><br><span class="line">To github.com:Zhoufenmianfan/GitStudy.git</span><br><span class="line">   ba2eadf..610e6ac  deev -&gt; deev</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我自己同时也开发了功能，add+commit到自己本地后，尝试push到我们共同的远程库。推送失败，因为你的小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单，Git已经提示我们，先用<code>git pull</code>把最新的提交从<code>origin/dev</code>抓下来，然后，在本地合并，解决冲突，再推送：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch deev</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line">        modified:   readme.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br><span class="line"></span><br><span class="line">$ git add readme.txt</span><br><span class="line"></span><br><span class="line">$ git commit -m &quot;add:Step 11&quot;</span><br><span class="line">[deev 20b6d5c] add:Step 11</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br><span class="line"></span><br><span class="line">$ git push origin deev</span><br><span class="line">To github.com:Zhoufenmianfan/GitStudy.git</span><br><span class="line"> ! [rejected]        deev -&gt; deev (fetch first)</span><br><span class="line">error: failed to push some refs to &#x27;github.com:Zhoufenmianfan/GitStudy.git&#x27;</span><br><span class="line">hint: Updates were rejected because the remote contains work that you do not</span><br><span class="line">hint: have locally. This is usually caused by another repository pushing to</span><br><span class="line">hint: the same ref. If you want to integrate the remote changes, use</span><br><span class="line">hint: &#x27;git pull&#x27; before pushing again.</span><br><span class="line">hint: See the &#x27;Note about fast-forwards&#x27; in &#x27;git push --help&#x27; for details.</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ git pull</span><br><span class="line">remote: Enumerating objects: 5, done.</span><br><span class="line">remote: Counting objects: 100% (5/5), done.</span><br><span class="line">remote: Compressing objects: 100% (1/1), done.</span><br><span class="line">remote: Total 3 (delta 2), reused 3 (delta 2), pack-reused 0</span><br><span class="line">Unpacking objects: 100% (3/3), 359 bytes | 1024 bytes/s, done.</span><br><span class="line">From github.com:Zhoufenmianfan/GitStudy</span><br><span class="line">   ba2eadf..610e6ac  deev       -&gt; origin/deev</span><br><span class="line">There is no tracking information for the current branch.</span><br><span class="line">Please specify which branch you want to merge with.</span><br><span class="line">See git-pull(1) for details.</span><br><span class="line"></span><br><span class="line">    git pull &lt;remote&gt; &lt;branch&gt;</span><br><span class="line"></span><br><span class="line">If you wish to set tracking information for this branch you can do so with:</span><br><span class="line"></span><br><span class="line">    git branch --set-upstream-to=origin/&lt;branch&gt; deev</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>git pull</code>也失败了，原因是没有指定本地<code>dev</code>分支与远程<code>origin/dev</code>分支的链接，根据提示，设置<code>dev</code>和<code>origin/dev</code>的链接：</p><p>🧊使用命令<code>git branch --set-upstream-to=origin/&lt;branch&gt; deev</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git branch --set-upstream-to=origin/deev deev</span><br><span class="line">branch &#x27;deev&#x27; set up to track &#x27;origin/deev&#x27;.</span><br><span class="line"></span><br><span class="line">$ git pull</span><br><span class="line">Auto-merging readme.txt</span><br><span class="line">CONFLICT (content): Merge conflict in readme.txt</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这回<code>git pull</code>成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的解决冲突完全一样。解决后，提交，再push：然后解决冲突，add+commit+push</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt</span><br><span class="line"></span><br><span class="line">$ git commit -m &quot;fix env conflict&quot;</span><br><span class="line">[deev 789d803] fix env conflict</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch deev</span><br><span class="line">Your branch is ahead of &#x27;origin/deev&#x27; by 2 commits.</span><br><span class="line">  (use &quot;git push&quot; to publish your local commits)</span><br><span class="line"></span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line"></span><br><span class="line">$ git push origin deev</span><br><span class="line">Enumerating objects: 10, done.</span><br><span class="line">Counting objects: 100% (10/10), done.</span><br><span class="line">Delta compression using up to 16 threads</span><br><span class="line">Compressing objects: 100% (6/6), done.</span><br><span class="line">Writing objects: 100% (6/6), 625 bytes | 625.00 KiB/s, done.</span><br><span class="line">Total 6 (delta 4), reused 0 (delta 0), pack-reused 0</span><br><span class="line">remote: Resolving deltas: 100% (4/4), completed with 2 local objects.</span><br><span class="line">To github.com:Zhoufenmianfan/GitStudy.git</span><br><span class="line">   610e6ac..789d803  deev -&gt; deev</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="分支变基"><a href="#分支变基" class="headerlink" title="分支变基"></a>分支变基</h4><p>首先将开发的deev分支用非快速方式进行分支合并，</p><p>🧊使用命令<code>git merge --no-ff -m &quot;merge with no-ff&quot; deev</code>，并注意这种方式会创建一个commit，因此需要写上message。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">$ git switch main</span><br><span class="line">Switched to branch &#x27;main&#x27;</span><br><span class="line"></span><br><span class="line">$ git merge --no-ff -m &quot;merge with two features&quot; deev</span><br><span class="line">Auto-merging readme.txt</span><br><span class="line">CONFLICT (content): Merge conflict in readme.txt</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br><span class="line"></span><br><span class="line">$ git add readme.txt</span><br><span class="line"></span><br><span class="line">$ git merge --no-ff -m &quot;merge with two features&quot; deev</span><br><span class="line">fatal: You have not concluded your merge (MERGE_HEAD exists).</span><br><span class="line">Please, commit your changes before you merge.</span><br><span class="line"></span><br><span class="line">$ git commit -m &quot;fix merge conflict&quot;</span><br><span class="line">[main 367ac85] fix merge conflict</span><br><span class="line"></span><br><span class="line">$ git merge --no-ff -m &quot;merge with two features&quot; deev</span><br><span class="line">Already up to date.</span><br><span class="line"></span><br><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line">*   367ac85 (HEAD -&gt; main) fix merge conflict</span><br><span class="line">|\</span><br><span class="line">| *   789d803 (origin/deev, deev) fix env conflict</span><br><span class="line">| |\</span><br><span class="line">| | * 610e6ac add:add a feature:step11</span><br><span class="line">| * | 20b6d5c add:Step 11</span><br><span class="line">| |/</span><br><span class="line">| * ba2eadf add:step10</span><br><span class="line">* | b99d80c (origin/main) add:step10</span><br><span class="line">* | bc2c1a8 delete:想想垃圾</span><br><span class="line">* | 9059eaa merge with no-ff</span><br><span class="line">|\|</span><br><span class="line">| * 7ff15b7 add:merge feature1</span><br><span class="line">|/</span><br><span class="line">*   a86de26 conflick fixed</span><br><span class="line">|\</span><br><span class="line">| * 19d592e add:new a branch feature1</span><br><span class="line">* | 9be30e1 add:Step 7</span><br><span class="line">|/</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在变基过程中出现了一些曲折因为之前数次错综复杂的加上远程库也进行了一次merge导致需要核对三次冲突，一起来看一下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">$ git rebase</span><br><span class="line">Auto-merging readme.txt</span><br><span class="line">CONFLICT (content): Merge conflict in readme.txt</span><br><span class="line">error: could not apply ba2eadf... add:step10</span><br><span class="line">hint: Resolve all conflicts manually, mark them as resolved with</span><br><span class="line">hint: &quot;git add/rm &lt;conflicted_files&gt;&quot;, then run &quot;git rebase --continue&quot;.</span><br><span class="line">hint: You can instead skip this commit: run &quot;git rebase --skip&quot;.</span><br><span class="line">hint: To abort and get back to the state before &quot;git rebase&quot;, run &quot;git rebase --abort&quot;.</span><br><span class="line">Could not apply ba2eadf... add:step10</span><br><span class="line"></span><br><span class="line">$ git rebase</span><br><span class="line">fatal: It seems that there is already a rebase-merge directory, and</span><br><span class="line">I wonder if you are in the middle of another rebase.  If that is the</span><br><span class="line">case, please try</span><br><span class="line">        git rebase (--continue | --abort | --skip)</span><br><span class="line">If that is not the case, please</span><br><span class="line">        rm -fr &quot;.git/rebase-merge&quot;</span><br><span class="line">and run me again.  I am stopping in case you still have something</span><br><span class="line">valuable there.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ git add readme.txt</span><br><span class="line"></span><br><span class="line">$ git commit -m &quot;fix rebase&quot;</span><br><span class="line">[detached HEAD df12556] fix rebase</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br><span class="line"></span><br><span class="line">$ git rebase --continue</span><br><span class="line">Auto-merging readme.txt</span><br><span class="line">CONFLICT (content): Merge conflict in readme.txt</span><br><span class="line">error: could not apply 20b6d5c... add:Step 11</span><br><span class="line">hint: Resolve all conflicts manually, mark them as resolved with</span><br><span class="line">hint: &quot;git add/rm &lt;conflicted_files&gt;&quot;, then run &quot;git rebase --continue&quot;.</span><br><span class="line">hint: You can instead skip this commit: run &quot;git rebase --skip&quot;.</span><br><span class="line">hint: To abort and get back to the state before &quot;git rebase&quot;, run &quot;git rebase --abort&quot;.</span><br><span class="line">Could not apply 20b6d5c... add:Step 11</span><br><span class="line"></span><br><span class="line">$ git add readme.txt</span><br><span class="line"></span><br><span class="line">$ git rebase --continue</span><br><span class="line">Auto-merging readme.txt</span><br><span class="line">CONFLICT (content): Merge conflict in readme.txt</span><br><span class="line">error: could not apply 610e6ac... add:add a feature:step11</span><br><span class="line">hint: Resolve all conflicts manually, mark them as resolved with</span><br><span class="line">hint: &quot;git add/rm &lt;conflicted_files&gt;&quot;, then run &quot;git rebase --continue&quot;.</span><br><span class="line">hint: You can instead skip this commit: run &quot;git rebase --skip&quot;.</span><br><span class="line">hint: To abort and get back to the state before &quot;git rebase&quot;, run &quot;git rebase --abort&quot;.</span><br><span class="line">Could not apply 610e6ac... add:add a feature:step11</span><br><span class="line"></span><br><span class="line">$ git add readme.txt</span><br><span class="line"></span><br><span class="line">$ git rebase --continue</span><br><span class="line">[detached HEAD efa0d7b] add:add a feature:step11</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line">Successfully rebased and updated refs/heads/main.</span><br><span class="line"></span><br><span class="line">$ git log --graph --pretty=oneline --abbrev-commit</span><br><span class="line">* efa0d7b (HEAD -&gt; main) add:add a feature:step11</span><br><span class="line">* df12556 fix rebase</span><br><span class="line">* 5307602 (origin/main) Deev (#2)</span><br><span class="line">* b99d80c add:step10</span><br><span class="line">* bc2c1a8 delete:想想垃圾</span><br><span class="line">*   9059eaa merge with no-ff</span><br><span class="line">|\</span><br><span class="line">| * 7ff15b7 add:merge feature1</span><br><span class="line">|/</span><br><span class="line">*   a86de26 conflick fixed</span><br><span class="line">|\</span><br><span class="line">| * 19d592e add:new a branch feature1</span><br><span class="line">* | 9be30e1 add:Step 7</span><br><span class="line">|/</span><br><span class="line">* 62d62a4 add:new a branch dev</span><br><span class="line">* 241aeea addfile:cancel.txt</span><br><span class="line">* 9c6fad0 add:Step 5</span><br><span class="line">* 674519f add:Step 4</span><br><span class="line">* 6185ab1 add:Step 3; addfile:LICENSE</span><br><span class="line">* a71de4e add:Step 2</span><br><span class="line">* 55fc0ac add:Step 1</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>原本分叉的提交现在变成一条直线了！这种神奇的操作是怎么实现的？其实原理非常简单。我们注意观察，发现Git把我们本地的提交“挪动”了位置，放到了前面的commit之后，这就是rebase操作的特点：把分叉的提交历史“整理”成一条直线，看上去更直观。缺点是本地的分叉提交已经被修改过了。最后，通过push操作把本地分支推送到远程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git push origin main</span><br><span class="line">Enumerating objects: 8, done.</span><br><span class="line">Counting objects: 100% (8/8), done.</span><br><span class="line">Delta compression using up to 16 threads</span><br><span class="line">Compressing objects: 100% (6/6), done.</span><br><span class="line">Writing objects: 100% (6/6), 551 bytes | 551.00 KiB/s, done.</span><br><span class="line">Total 6 (delta 4), reused 0 (delta 0), pack-reused 0</span><br><span class="line">remote: Resolving deltas: 100% (4/4), completed with 2 local objects.</span><br><span class="line">To github.com:Zhoufenmianfan/GitStudy.git</span><br><span class="line">   5307602..efa0d7b  main -&gt; main</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">Git是什么？Github和它一样吗？</summary>
    
    
    
    <category term="Tech" scheme="https://zhoufenmianfan.github.io/categories/Tech/"/>
    
    
    <category term="Computer" scheme="https://zhoufenmianfan.github.io/tags/Computer/"/>
    
    <category term="Git" scheme="https://zhoufenmianfan.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>原来：Git可以帮你管理杂乱的不同版本文件</title>
    <link href="https://zhoufenmianfan.github.io/2024/02/27/Git%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E6%95%99%E7%A8%8BPart1/"/>
    <id>https://zhoufenmianfan.github.io/2024/02/27/Git%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6%E6%95%99%E7%A8%8BPart1/</id>
    <published>2024-02-27T07:56:00.000Z</published>
    <updated>2024-03-10T04:56:39.560Z</updated>
    
    <content type="html"><![CDATA[<p>🚫本教程参照<a href="https://www.liaoxuefeng.com/wiki/896043488029600">廖雪峰的官方网站</a>教程，请优先参考其网站。</p><h2 id="Git的下载安装"><a href="#Git的下载安装" class="headerlink" title="Git的下载安装"></a>Git的下载安装</h2><p>安装渠道：<a href="https://git-scm.com/">Git官网</a></p><h2 id="Git简介"><a href="#Git简介" class="headerlink" title="Git简介"></a>Git简介</h2><p>提供各种各样的版本文件管理思路与流程，Git是工具，Github是一个服务器性质的集代码托管、论坛、开发等功能于一体的平台。</p><p>首先这里再明确一下，所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等，Git也不例外。版本控制系统可以告诉你每次的改动，比如在第5行加了一个单词“Linux”，在第8行删了一个单词“Windows”。而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。</p><p>不幸的是，Microsoft的Word格式是二进制格式，因此，版本控制系统是没法跟踪Word文件的改动的，前面我们举的例子只是为了演示，如果要真正使用版本控制系统，就要以纯文本方式编写文件。</p><p>因为文本是有编码的，比如中文有常用的GBK编码，日文有Shift_JIS编码，如果没有历史遗留问题，强烈建议使用标准的UTF-8编码，所有语言使用同一种编码，既没有冲突，又被所有平台所支持。</p><h2 id="Git使用"><a href="#Git使用" class="headerlink" title="Git使用"></a>Git使用</h2><h3 id="Git仓库"><a href="#Git仓库" class="headerlink" title="Git仓库"></a>Git仓库</h3><p>版本库又名仓库，英文名repository，可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。</p><h4 id="仓库创建"><a href="#仓库创建" class="headerlink" title="仓库创建"></a>仓库创建</h4><p>🧊使用命令<code>git init</code>初始化一个仓库，以当前目录作为Git仓库</p><h4 id="文件创建"><a href="#文件创建" class="headerlink" title="文件创建"></a>文件创建</h4><p>文件自身的创建是和Git没有关系的，可以用windows的可视化操作创建，也可以用终端指令创建任意文件or目录。</p><h4 id="文件添加"><a href="#文件添加" class="headerlink" title="文件添加"></a>文件添加</h4><p>🧊使用命令<code>git add</code>将任意一个文件添加到Git仓库，可以认为是暂时提交到Git仓库中的一个池子pool中</p><h4 id="文件提交"><a href="#文件提交" class="headerlink" title="文件提交"></a>文件提交</h4><p>🧊使用命令<code>git commit</code>将前面add操作添加到池子pool中的文件提交到仓库，因此add只能添加一个文件，但是commit可以一次性将pool中的所有文件提交。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.json</span><br><span class="line">$ git add readme.txt</span><br><span class="line">$ git commit -m &quot;add:Step 1&quot;</span><br><span class="line">[master (root-commit) 55fc0ac] add:Step 1</span><br><span class="line"> 2 files changed, 5 insertions(+)</span><br><span class="line"> create mode 100644 readme.json</span><br><span class="line"> create mode 100644 readme.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="文件修改"><a href="#文件修改" class="headerlink" title="文件修改"></a>文件修改</h4><p>自定义修改文件内容，保存文件内容。</p><h4 id="状态查看"><a href="#状态查看" class="headerlink" title="状态查看"></a>状态查看</h4><p>🧊使用命令<code>git status</code>查看当前仓库内的文件和上一次commit操作后的文件差异，提示在主分支<code>On branch master</code>被修改过了，<code>Changes not staged for commit:</code>但还没有准备提交的修改文件<code>modified:   readme.txt</code>，推荐你使用命令<code>git add &lt;file&gt;</code>去将这个文件添加到pool中以备后续commit，或者使用命令<code>git restore &lt;file&gt;</code>去忽略这部分改动。<code>no changes added to commit</code>没有新的通过add文件到pool中去用于commit。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line">        modified:   readme.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="比较查看"><a href="#比较查看" class="headerlink" title="比较查看"></a>比较查看</h4><p>🧊使用命令<code>git diff</code>查看具体修改的内容，显示的格式是Unix通用的diff格式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ git diff</span><br><span class="line">diff --git a/readme.txt b/readme.txt</span><br><span class="line">index 80a2774..19ac55a 100644</span><br><span class="line">--- a/readme.txt</span><br><span class="line">+++ b/readme.txt</span><br><span class="line">@@ -1,2 +1,3 @@</span><br><span class="line"> Git test：</span><br><span class="line">-step1：文件自身的创建是和Git没有关系的，可以用windows的可视化操作创建，也可以用终端指令创建任意文件or目录。</span><br><span class="line">\ No newline at end of file</span><br><span class="line">+step1：文件自身的创建是和Git，【这里删除了“没有关系的”】可以用windows的可视化操作创建，也可以用终端指令创建任意文件or目录。</span><br><span class="line">+step2：🧊使用命令`git add`将任意一个文件添加到Git仓库，可以认为是暂时提交到Git</span><br><span class="line">仓库中的一个池子pool中</span><br><span class="line">\ No newline at end of file</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过下面这一段可以发现，如果改动了文件a，中间保存过内容b，然后再把内容改回a，这样同样是能够被检测出来的。只要git目录下的已提交文件的同名文件被修改或删除了，就可以用git diff 来查看具体发生了什么修改（不需要等到add以后才能查）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git diff</span><br><span class="line">diff --git a/readme.txt b/readme.txt</span><br><span class="line">index 80a2774..7d21f15 100644</span><br><span class="line">--- a/readme.txt</span><br><span class="line">+++ b/readme.txt</span><br><span class="line">@@ -1,2 +1,3 @@</span><br><span class="line"> Git test：</span><br><span class="line">-step1：文件自身的创建是和Git没有关系的，可以用windows的可视化操作创建，也可以用终端指令创建任意文件or目录。</span><br><span class="line">\ No newline at end of file</span><br><span class="line">+step1：文件自身的创建是和Git没有关系的，可以用windows的可视化操作创建，也可以用终端指令创建任意文件or目录。</span><br><span class="line">+step2：🧊使用命令`git add`将任意一个文件添加到Git仓库，可以认为是暂时提交到Git仓库中的一个池子pool中</span><br><span class="line">\ No newline at end of file</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="修改添加"><a href="#修改添加" class="headerlink" title="修改添加"></a>修改添加</h4><p>🧊使用命令<code>git add</code>将修改动的文件再次添加到pool。</p><p>🧊使用命令<code>git status</code>再次查看仓库中文件的状态信息，文件<code>modified:   readme.txt</code>准备被提交<code>Changes to be committed:</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage)</span><br><span class="line">        modified:   readme.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="修改提交"><a href="#修改提交" class="headerlink" title="修改提交"></a>修改提交</h4><p>🧊使用命令<code>git commit</code>将pool中的文件提交给Git进行版本更新，提示<code> 1 file changed, 2 insertions(+), 1 deletion(-)</code>1个文件发生改动，添加2行，删除1处。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &quot;add:Step 2&quot;</span><br><span class="line">[master a71de4e] add:Step 2</span><br><span class="line"> 1 file changed, 2 insertions(+), 1 deletion(-)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然后使用命令<code>git status</code>继续查看仓库文件状态信息，提示主分支<code>On branch master</code>下是整洁的，即没有改动也没有需要提交的文件<code>nothing to commit, working tree clean</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="仓库版本"><a href="#仓库版本" class="headerlink" title="仓库版本"></a>仓库版本</h3><p>每当你觉得文件修改到一定程度的时候，就可以“保存一个快照”，这个快照在Git中被称为<code>commit</code>。一旦你把文件改乱了，或者误删了文件，还可以从最近的一个<code>commit</code>恢复，然后继续工作，而不是把几个月的工作成果全部丢失。</p><h4 id="版本查看"><a href="#版本查看" class="headerlink" title="版本查看"></a>版本查看</h4><p>🧊使用命令<code>git log</code>查看当前仓库下的所有commit版本，显示从最近到最远的提交日志</p><p>📌一大串类似<code>a71de4e70d30...</code>的是<code>commit id</code>（版本号），和SVN不一样，Git的<code>commit id</code>不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示，而且你看到的<code>commit id</code>和我的肯定不一样，以你自己的为准。为什么<code>commit id</code>需要用这么一大串数字表示呢？因为Git是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了，这种分布式计算方式简单地说就是让没有互相通信的人各自独立的生成自己的版本号，结果俩人版本号冲突发生的概率趋向于无穷小，这样就可以认为永远不会发生冲突。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git log</span><br><span class="line">commit a71de4e70d30009b6f3dab4e25ed22e42d092929 (HEAD -&gt; master)</span><br><span class="line">Author: DESKTOP-SP0MN28\16485 &lt;164854196@qq.com&gt;</span><br><span class="line">Date:   Wed Feb 28 13:09:43 2024 +0800</span><br><span class="line"></span><br><span class="line">    add:Step 2</span><br><span class="line"></span><br><span class="line">commit 55fc0ac6bcca68900cd342f8c48852ae55ecbd85</span><br><span class="line">Author: DESKTOP-SP0MN28\16485 &lt;164854196@qq.com&gt;</span><br><span class="line">Date:   Wed Feb 28 12:39:33 2024 +0800</span><br><span class="line"></span><br><span class="line">    add:Step 1</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="版本回退-前进"><a href="#版本回退-前进" class="headerlink" title="版本回退&#x2F;前进"></a>版本回退&#x2F;前进</h4><p>📌在Git中，用<code>HEAD</code>表示当前版本，也就是最新的提交<code>a71de4e70d30...</code>（注意我的提交ID和你的肯定不一样），上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，当然往上100个版本写100个<code>^</code>比较容易数不过来，所以写成<code>HEAD~100</code>。</p><p>🧊使用命令<code>git reset</code>来回到过去的commit版本，然后查看内容是否符合。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard HEAD^</span><br><span class="line">HEAD is now at 55fc0ac add:Step 1</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>🧊使用命令<code>git log</code>查看当前仓库下的所有commit版本，发现已经没有了<code>add:Step 2</code>那个版本（但是实际上还在）</p><p>📌Git的版本回退速度非常快，因为Git在内部有个指向当前版本的<code>HEAD</code>指针，当你回退版本的时候，Git仅仅是把HEAD从指向<code>add:Step 1</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git log</span><br><span class="line">commit 55fc0ac6bcca68900cd342f8c48852ae55ecbd85 (HEAD -&gt; master)</span><br><span class="line">Author: DESKTOP-SP0MN28\16485 &lt;164854196@qq.com&gt;</span><br><span class="line">Date:   Wed Feb 28 12:39:33 2024 +0800</span><br><span class="line"></span><br><span class="line">    add:Step 1</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>🧊使用命令<code>git reset</code>来前进到未来的commit版本，只需要找到未来那个版本的<code>commit id</code>，只需要输入前几位，一般都可以自动索引到那个版本。</p><p>📌版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard a71de4</span><br><span class="line">HEAD is now at a71de4e add:Step 2</span><br><span class="line"></span><br><span class="line">$ git log</span><br><span class="line">commit a71de4e70d30009b6f3dab4e25ed22e42d092929 (HEAD -&gt; master)</span><br><span class="line">Author: DESKTOP-SP0MN28\16485 &lt;164854196@qq.com&gt;</span><br><span class="line">Date:   Wed Feb 28 13:09:43 2024 +0800</span><br><span class="line"></span><br><span class="line">    add:Step 2</span><br><span class="line"></span><br><span class="line">commit 55fc0ac6bcca68900cd342f8c48852ae55ecbd85</span><br><span class="line">Author: DESKTOP-SP0MN28\16485 &lt;164854196@qq.com&gt;</span><br><span class="line">Date:   Wed Feb 28 12:39:33 2024 +0800</span><br><span class="line"></span><br><span class="line">    add:Step 1</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>📌如果无法找回<code>commit id</code>，在Git中，当你用<code>$ git reset --hard HEAD^</code>回退到<code>add:Step 1</code>版本时，再想恢复到<code>add:Step 2</code>，就必须找到<code>add:Step 2</code>的commit id。Git提供了一个命令<code>git reflog</code>用来记录你的每一次命令：这样就可以找到当初<code>add:Step 2</code>步骤的<code>commit id</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git reflog</span><br><span class="line">a71de4e (HEAD -&gt; master) HEAD@&#123;0&#125;: reset: moving to a71de4</span><br><span class="line">55fc0ac HEAD@&#123;1&#125;: reset: moving to HEAD^</span><br><span class="line">a71de4e (HEAD -&gt; master) HEAD@&#123;2&#125;: commit: add:Step 2</span><br><span class="line">55fc0ac HEAD@&#123;3&#125;: commit (initial): add:Step 1</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="Git理解"><a href="#Git理解" class="headerlink" title="Git理解"></a>Git理解</h2><h3 id="Git分区"><a href="#Git分区" class="headerlink" title="Git分区"></a>Git分区</h3><h4 id="工作区"><a href="#工作区" class="headerlink" title="工作区"></a>工作区</h4><p>就是所有与你工作相关的文件，或者说Git需要去管理的区域。</p><h4 id="版本库"><a href="#版本库" class="headerlink" title="版本库"></a>版本库</h4><p>工作区有一个隐藏目录<code>.git</code>，这个不算工作区，而是Git的版本库。Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支<code>master</code>，以及指向<code>master</code>的一个指针叫<code>HEAD</code>。</p><p><img src="https://raw.githubusercontent.com/Zhoufenmianfan/images/main/202402281345961.png"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p><h4 id="暂存区"><a href="#暂存区" class="headerlink" title="暂存区"></a>暂存区</h4><p>📌第一步是用<code>git add</code>把文件添加进去，实际上就是把文件修改添加到暂存区；第二步是用<code>git commit</code>提交更改，实际上就是把暂存区的所有内容提交到当前分支。因为我们创建Git版本库时，Git自动为我们创建了唯一一个<code>master</code>分支，所以，现在，<code>git commit</code>就是往<code>master</code>分支上提交更改。可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。</p><p>新建立一个LICENSE文件，并且给readme.txt文件添加一个step3的内容，再用命令<code>git status</code>查看仓库状态，Git非常清楚地告诉我们，<code>readme.txt</code>被修改了，而<code>LICENSE</code>还从来没有被添加过，所以它的状态是<code>Untracked</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line">        modified:   readme.txt</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line">        LICENSE</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>现在，使用两次命令<code>git add</code>或者<code>git add --all</code>，把<code>readme.txt</code>和<code>LICENSE</code>都添加后，用<code>git status</code>再查看一下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git add --all</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage)</span><br><span class="line">        new file:   LICENSE</span><br><span class="line">        modified:   readme.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Zhoufenmianfan/images/main/202402281354622.png"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p><p>所以，<code>git add</code>命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行<code>git commit</code>就可以一次性把暂存区的所有修改提交到分支。一旦提交后，如果你又没有对工作区做任何修改，那么工作区就是“整洁”的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &quot;add:Step 3; addfile:LICENSE&quot;</span><br><span class="line">[master 6185ab1] add:Step 3; addfile:LICENSE</span><br><span class="line"> 2 files changed, 2 insertions(+), 1 deletion(-)</span><br><span class="line"> create mode 100644 LICENSE</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/Zhoufenmianfan/images/main/202402281356027.png"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p><h3 id="Git修改"><a href="#Git修改" class="headerlink" title="Git修改"></a>Git修改</h3><p>为什么Git比其他版本控制系统设计得优秀，因为Git跟踪并管理的是修改，而非文件。</p><h4 id="修改文件"><a href="#修改文件" class="headerlink" title="修改文件"></a>修改文件</h4><p>首先将readme.txt文件改成a状态，再add，查看状态status，再将readme.txt文件改成b状态，再直接提交commit，再查看状态status。可以发现仍然存在着第二次修改没有被提交，但是我们此刻工作区中保存的文件已经是经历了两次修改的文件了，也就是说，我们在第一次修改之后就在这处修改已经打了一个标记，只要后续的修改没有被add到暂存区，那么都不会影响commit提交的版本。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git add readme.txt</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage)</span><br><span class="line">        modified:   readme.txt</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line">        modified:   readme.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m &quot;add:Step 4&quot;</span><br><span class="line">[master 674519f] add:Step 4</span><br><span class="line"> 1 file changed, 2 insertions(+), 1 deletion(-)</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line">        modified:   readme.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h4><p>如果编辑了文件保存了，那么就会在Git的监管下发现有文件状态变化，但是只要没有add到stage就可以在无状态更新情况下把文件手动改回原来状态：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line">        modified:   readme.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>也可以使用Git的命令<code>git restore</code>来回退到原来的文件，一种是<code>readme.txt</code>自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；一种是<code>readme.txt</code>已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。总之，就是让这个文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态。</p><p>另一种撤销修改的命令是<code>git checkout -- readme.txt</code>，意思就是，把<code>readme.txt</code>文件在工作区的修改全部撤销，<code>git checkout -- file</code>命令中的<code>--</code>很重要，没有<code>--</code>，就变成了“切换到另一个分支”的命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line">        modified:   readme.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br><span class="line"></span><br><span class="line">$ git restore readme.txt</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="撤销添加"><a href="#撤销添加" class="headerlink" title="撤销添加"></a>撤销添加</h4><p>如果已经将文件修改添加到了暂存区，但是又想撤销这次添加，Git同样告诉我们，用命令<code>git reset HEAD &lt;file&gt;</code>可以把暂存区的修改撤销掉（unstage），重新放回工作区，但是这时候的工作区文件还是有修改：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line">        modified:   readme.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br><span class="line"></span><br><span class="line">$ git diff</span><br><span class="line">diff --git a/readme.txt b/readme.txt</span><br><span class="line">index b865854..016f23f 100644</span><br><span class="line">--- a/readme.txt</span><br><span class="line">+++ b/readme.txt</span><br><span class="line">@@ -3,4 +3,5 @@ step1：文件自身的创建是和Git没有关系的，可以用windows的可</span><br><span class="line"> step2：🧊使用命令`git add`将任意一个文件添加到Git仓库，可以认为是暂时提交到Git仓库中的一个池子pool中</span><br><span class="line"> step3：🧊使用命令`git commit`将前面add操作添加到池子pool中的文件提交到仓库，因此add只能添加一个文件，但是commit可以一次性将pool中的所有文件</span><br><span class="line">提交。</span><br><span class="line"> step4：自定义修改文件内容，保存文件内容。</span><br><span class="line">-step5：🧊使用命令`git status`查看当前仓库内的文件和上一次commit操作后的文件差异，提示在主分支`On branch master`被修改过了，`Changes not staged for commit:`但还没有准备提交的修改文件`modified:   readme.txt`，推荐你使用命令`git add &lt;file&gt;`去将这个文件添加到pool中以备后续commit，或者使用命令`git restore &lt;file&gt;`去忽略这部分改动。`no changes added to commit`没有新的通过add文件到pool中去用于commit。</span><br><span class="line">\ No newline at end of file</span><br><span class="line">+step5：🧊使用命令`git status`查看当前仓库内的文件和上一次commit操作后的文件差异，提示在主分支`On branch master`被修改过了，`Changes not staged for commit:`但还没有准备提交的修改文件`modified:   readme.txt`，推荐你使用命令`git add &lt;file&gt;`去将这个文件添加到pool中以备后续commit，或者使用命令`git restore &lt;file&gt;`去忽略这部分改动。`no changes added to commit`没有新的通过add文件到pool中去用于commit。</span><br><span class="line">+这是一次没必要的添加</span><br><span class="line">\ No newline at end of file</span><br><span class="line"></span><br><span class="line">$ git add readme.txt</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage)</span><br><span class="line">        modified:   readme.txt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">16485@DESKTOP-HCCK4RT MINGW64 /d/HZY/MyFiles/06_MyProject/08_Git/Test (master)</span><br><span class="line">$ git restore --staged readme.txt</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line">        modified:   readme.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br><span class="line"></span><br><span class="line">$ git diff</span><br><span class="line">diff --git a/readme.txt b/readme.txt</span><br><span class="line">index b865854..016f23f 100644</span><br><span class="line">--- a/readme.txt</span><br><span class="line">+++ b/readme.txt</span><br><span class="line">@@ -3,4 +3,5 @@ step1：文件自身的创建是和Git没有关系的，可以用windows的可</span><br><span class="line"> step2：🧊使用命令`git add`将任意一个文件添加到Git仓库，可以认为是暂时提交到Git仓库中的一个池子pool中</span><br><span class="line"> step3：🧊使用命令`git commit`将前面add操作添加到池子pool中的文件提交到仓库，因此add只能添加一个文件，但是commit可以一次性将pool中的所有文件</span><br><span class="line">提交。</span><br><span class="line"> step4：自定义修改文件内容，保存文件内容。</span><br><span class="line">-step5：🧊使用命令`git status`查看当前仓库内的文件和上一次commit操作后的文件差异，提示在主分支`On branch master`被修改过了，`Changes not staged for commit:`但还没有准备提交的修改文件`modified:   readme.txt`，推荐你使用命令`git add &lt;file&gt;`去将这个文件添加到pool中以备后续commit，或者使用命令`git restore &lt;file&gt;`去忽略这部分改动。`no changes added to commit`没有新的通过add文件到pool中去用于commit。</span><br><span class="line">\ No newline at end of file</span><br><span class="line">+step5：🧊使用命令`git status`查看当前仓库内的文件和上一次commit操作后的文件差异，提示在主分支`On branch master`被修改过了，`Changes not staged for commit:`但还没有准备提交的修改文件`modified:   readme.txt`，推荐你使用命令`git add &lt;file&gt;`去将这个文件添加到pool中以备后续commit，或者使用命令`git restore &lt;file&gt;`去忽略这部分改动。`no changes added to commit`没有新的通过add文件到pool中去用于commit。</span><br><span class="line">+这是一次没必要的添加</span><br><span class="line">\ No newline at end of file</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>现在把工作区的文件修改也撤销了，使用命令<code>git checkout -- readme.txt</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -- readme.txt</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="文件删除"><a href="#文件删除" class="headerlink" title="文件删除"></a>文件删除</h4><p>在Git中，删除也是一个修改操作，一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用<code>rm</code>命令删了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Untracked files:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)</span><br><span class="line">        cancel.txt</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use &quot;git add&quot; to track)</span><br><span class="line"></span><br><span class="line">$ git add cancel.txt</span><br><span class="line"></span><br><span class="line">$ git commit -m &quot;addfile:cancel.txt&quot;</span><br><span class="line">[master 241aeea] addfile:cancel.txt</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 cancel.txt</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>手动删除文件，被Git检测到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ rm cancel.txt</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add/rm &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line">        deleted:    cancel.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令<code>git rm</code>删掉，并且<code>git commit</code>：</p><p>📌注意使用<code>git add</code>和<code>git rm</code>效果是一样的，因为Git把删除也视为一次文件修改操作，并不因为这个操作让这个文件消失而变得特殊</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ git add cancel.txt</span><br><span class="line"></span><br><span class="line">$ git commit -m &quot;delfile:cancel.txt&quot;</span><br><span class="line">[master 7b48424] delfile:cancel.txt</span><br><span class="line"> 1 file changed, 1 deletion(-)</span><br><span class="line"> delete mode 100644 cancel.txt</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本，这里使用了前面提到过的版本回退，让我们退回到添加了cancel文件的commit状态：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ git reset --hard HEAD^</span><br><span class="line">HEAD is now at 241aeea addfile:cancel.txt</span><br><span class="line"></span><br><span class="line">$ rm cancel.txt</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add/rm &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line">        deleted:    cancel.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br><span class="line"></span><br><span class="line">$ git checkout -- cancel.txt</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>📌<code>git checkout</code>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。命令<code>git rm</code>用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失<strong>最近一次提交后你修改的内容</strong>。</p><h4 id="场景小结"><a href="#场景小结" class="headerlink" title="场景小结"></a>场景小结</h4><p>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code>。</p><p>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD &lt;file&gt;</code>，就回到了场景1，第二步按场景1操作。</p><p>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库如Github。</p><h2 id="Git优势"><a href="#Git优势" class="headerlink" title="Git优势"></a>Git优势</h2><h3 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h3><p>Git是分布式版本控制系统，同一个Git仓库，可以分布到不同的机器上。怎么分布呢？最早，肯定只有一台机器有一个原始版本库，此后，别的机器可以“克隆”这个原始版本库，而且每台机器的版本库其实都是一样的，并没有主次之分。实际情况往往是这样，找一台电脑充当服务器的角色，每天24小时开机，其他每个人都从这个“服务器”仓库克隆一份到自己的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交。完全可以自己搭建一台运行Git的服务器，不过现阶段，为了学Git先搭个服务器绝对是小题大作。好在这个世界上有个叫<a href="https://github.com/">GitHub</a>的神奇的网站，从名字就可以看出，这个网站就是提供Git仓库托管服务的，所以，只要注册一个GitHub账号，就可以免费获得Git远程仓库。</p><h4 id="Github远程仓库"><a href="#Github远程仓库" class="headerlink" title="Github远程仓库"></a>Github远程仓库</h4><p>请直接去<a href="https://github.com/">Github官网</a>注册一个账户。</p><h4 id="Github-SSH-key设置"><a href="#Github-SSH-key设置" class="headerlink" title="Github SSH key设置"></a>Github SSH key设置</h4><p>📌以下内容略写，请查阅相关其他资料</p><ul><li>第1步：创建SSH Key。</li><li>第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面：然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴<code>id_rsa.pub</code>文件的内容：</li></ul><p>为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。</p><p>当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。</p><h4 id="Github仓库推送"><a href="#Github仓库推送" class="headerlink" title="Github仓库推送"></a>Github仓库推送</h4><p>按照Github提示执行指令将本地的仓库代码推送到Github，添加后，远程库的名字就是<code>origin</code>，这是Git默认的叫法，也可以改成别的，但是<code>origin</code>这个名字一看就知道是远程库。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:Zhoufenmianfan/GitStudy.git</span><br><span class="line">git branch -M main</span><br><span class="line">git push -u origin main</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git push -u origin main</span><br><span class="line">Enumerating objects: 20, done.</span><br><span class="line">Counting objects: 100% (20/20), done.</span><br><span class="line">Delta compression using up to 16 threads</span><br><span class="line">Compressing objects: 100% (17/17), done.</span><br><span class="line">Writing objects: 100% (20/20), 2.14 KiB | 2.14 MiB/s, done.</span><br><span class="line">Total 20 (delta 7), reused 0 (delta 0), pack-reused 0</span><br><span class="line">remote: Resolving deltas: 100% (7/7), done.</span><br><span class="line">To github.com:Zhoufenmianfan/GitStudy.git</span><br><span class="line"> * [new branch]      main -&gt; main</span><br><span class="line">branch &#x27;main&#x27; set up to track &#x27;origin/main&#x27;.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>📌由于远程库是空的，我们第一次推送<code>main</code>分支时，加上了<code>-u</code>参数，Git不但会把本地的<code>main</code>分支内容推送的远程新的<code>main</code>分支，还会把本地的<code>main</code>分支和远程的<code>main</code>分支关联起来，在以后的推送或者拉取时就可以简化命令。</p><h4 id="Github仓库绑定解除"><a href="#Github仓库绑定解除" class="headerlink" title="Github仓库绑定解除"></a>Github仓库绑定解除</h4><p>想解除本地与远程仓库的连接，可以用<code>git remote rm &lt;name&gt;</code>命令。使用前，建议先用<code>git remote -v</code>查看远程库信息，这里的<code>rm</code>是解除了本地和远程的绑定关系，并不是物理上删除了远程库。远程库本身并没有任何改动。要真正删除远程库，需要登录到GitHub，在后台页面找到删除按钮再删除。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin  git@github.com:Zhoufenmianfan/GitStudy.git (fetch)</span><br><span class="line">origin  git@github.com:Zhoufenmianfan/GitStudy.git (push)</span><br><span class="line"></span><br><span class="line">$ git remote rm origin</span><br><span class="line"></span><br><span class="line">$ git remote -v</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="远程库克隆"><a href="#远程库克隆" class="headerlink" title="远程库克隆"></a>远程库克隆</h4><p>假设我们从零开发，那么最好的方式是先创建远程库，然后，从远程库克隆。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git clone git@github.com:Zhoufenmianfan/Zhoufenmianfan.github.io.git</span><br><span class="line">Cloning into &#x27;Zhoufenmianfan.github.io&#x27;...</span><br><span class="line">remote: Enumerating objects: 570, done.</span><br><span class="line">remote: Counting objects: 100% (569/569), done.</span><br><span class="line">remote: Compressing objects: 100% (187/187), done.</span><br><span class="line">remote: Total 570 (delta 241), reused 560 (delta 232), pack-reused 1</span><br><span class="line">Receiving objects: 100% (570/570), 3.38 MiB | 1.99 MiB/s, done.</span><br><span class="line">Resolving deltas: 100% (241/241), done.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>📌GitHub给出的地址不止一个，还可以用<code>https://github.com/michaelliao/gitskills.git</code>这样的地址。实际上，Git支持多种协议，默认的<code>git://</code>使用ssh，但也可以使用<code>https</code>等其他协议。使用<code>https</code>除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用<code>ssh</code>协议而只能用<code>https</code>。</p>]]></content>
    
    
    <summary type="html">Git是什么？Github和它一样吗？</summary>
    
    
    
    <category term="Tech" scheme="https://zhoufenmianfan.github.io/categories/Tech/"/>
    
    
    <category term="Computer" scheme="https://zhoufenmianfan.github.io/tags/Computer/"/>
    
    <category term="Git" scheme="https://zhoufenmianfan.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>我想：和小伙伴一起玩MC整合包</title>
    <link href="https://zhoufenmianfan.github.io/2024/01/12/Minecraft%E5%BC%80%E6%9C%8D%E6%B5%81%E7%A8%8B%E7%AE%80%E8%BF%B0/"/>
    <id>https://zhoufenmianfan.github.io/2024/01/12/Minecraft%E5%BC%80%E6%9C%8D%E6%B5%81%E7%A8%8B%E7%AE%80%E8%BF%B0/</id>
    <published>2024-01-12T07:56:00.000Z</published>
    <updated>2024-01-12T07:02:49.760Z</updated>
    
    <content type="html"><![CDATA[<h2 id="开服配方"><a href="#开服配方" class="headerlink" title="开服配方"></a>开服配方</h2><ul><li>服务端：Curseforge网站提供服务端Pack、Windows系统、本地局域网环境</li><li>客户端：Curseforge网站提供服务端Pack、HMCL启动器、Windows系统、本地局域网环境</li></ul><h2 id="本地客户端配置"><a href="#本地客户端配置" class="headerlink" title="本地客户端配置"></a>本地客户端配置</h2><ul><li>HMCL：<a href="https://github.com/HMCL-dev/HMCL">下载链接</a>，直接下载到任意目录下启动，按照内部说明下载游戏本体或整合包</li><li>Java：不同的游戏版本需要使用不同的Java版本，JDK&#x2F;JRE都可以</li><li>MC：这里体验一下<a href="https://www.curseforge.com/minecraft/modpacks/better-mc-forge-bmc3">Better-MC-FORGE1.19.2</a>，下载整合包（HMCL搜索或者官网下载后本地导入均可）</li></ul><h2 id="远程服务端配置"><a href="#远程服务端配置" class="headerlink" title="远程服务端配置"></a>远程服务端配置</h2><ul><li>MC-server：下载解压<a href="https://www.curseforge.com/minecraft/modpacks/better-mc-forge-bmc3/files/4889426">Sever版本</a>，运行其中的Powershell脚本start.ps1，其中需要联网下载依赖，所以可能需要科学上网环境，如果服务端不能实现科学上网环境，可以本地端运行start.ps1后，将整个文件目录拷贝到服务端，再重新运行start.ps1，即可以实现跳过下载依赖的环节</li><li>Powershell：由于RDP登录后退出，远程服务器会自动停止远程用户下的所有任务（包括Powershell），因此需要用一定的方法使其继续运行<ul><li>方法一：cmd&#x2F;Powershell 输入query session 查找本次RDP服务的用户ID，然后执行指令 tscon 来退出RDP的同时保证该用户下任务继续执行。</li></ul></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> 会话名            用户名                   ID  状态    类型        设备</span><br><span class="line"> services                                    0  断开</span><br><span class="line">&gt;console           16485                     2  运行中</span><br><span class="line"> 31c5ce94259d4...                        65536  侦听</span><br><span class="line"> rdp-tcp                                 65537  侦听</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tscon ID /password:* /dest:console</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">双Windows平台下的服务端与客户端游玩MC流程</summary>
    
    
    
    <category term="Tech" scheme="https://zhoufenmianfan.github.io/categories/Tech/"/>
    
    
    <category term="Minecraft" scheme="https://zhoufenmianfan.github.io/tags/Minecraft/"/>
    
  </entry>
  
  <entry>
    <title>原来：英文单词构词可以这样理解</title>
    <link href="https://zhoufenmianfan.github.io/2024/01/07/English%E8%AF%8D%E7%B4%A0%E6%9E%84%E8%AF%8D%E7%90%86%E8%AE%BA/"/>
    <id>https://zhoufenmianfan.github.io/2024/01/07/English%E8%AF%8D%E7%B4%A0%E6%9E%84%E8%AF%8D%E7%90%86%E8%AE%BA/</id>
    <published>2024-01-07T07:56:00.000Z</published>
    <updated>2024-01-09T06:22:58.595Z</updated>
    
    <content type="html"><![CDATA[<h2 id="构词理论"><a href="#构词理论" class="headerlink" title="构词理论"></a>构词理论</h2><ul><li><strong>传统构词理论</strong>：英语的主要构词方式有3种：转化、合成与派生。<ul><li>转化只是单词词类的转变，不涉及词形的变化；</li><li>合成是两个或两个以上单词合并成新词；</li><li>派生则是通过添加词缀从一个单词产生新的单词。</li></ul></li><li><strong>词素构词理论</strong>：可以将各种传统的构词法包容在派生法之中。<ul><li>词根不加缀的“零级派生”可以产生简单词、原始复合词、转化词和合成词；</li><li>粘附词根加原生词缀的“一级派生”产生原始派生词（或原生词）；</li><li>自由词根或单词加派生词缀的“二级派生”产生二次派生词，即传统意义上的派生词。</li></ul></li></ul><h2 id="词素构词理论"><a href="#词素构词理论" class="headerlink" title="词素构词理论"></a>词素构词理论</h2><ul><li><p><strong>零级派生</strong>：<strong>无词缀构词</strong>（Non-affixation）：在这类构词方式中，参加构词的只有词根词素。</p><ul><li><strong>粘附词根构词</strong>：“粘附词根+零原生词缀”<ul><li>1）粘附词根+零原生词缀→简单词（Primary Word）：<blockquote><p>act（做）+零原生词缀→act n.行为</p><p>firm（固定的）+零原生词缀→firm a.结实的</p></blockquote></li><li>2）粘附词根+粘附词根+零原生词辍→原始复合词（Primitive Compound）：<blockquote><p>manu（手）+script（写）→manuscript n.手稿</p><p>ped（男孩）+agogue（引导）→pedagogue n.教师</p></blockquote></li></ul></li><li><strong>自由词根构词</strong>：“自由词根+零派生词缀”<ul><li>1）自由词根+零派生词缀→转化词（Conversed Word）：<blockquote><p>firm a.结实的+零派生词缀→firm v.使坚定</p><p>man n.人+零派生词缀→man v.给……配备人员</p></blockquote></li><li>2）自由词根+自由词根+零派生词辍→合成词（Compound Word）：<blockquote><p>black a.黑色的+board n.板→blackboard n.黑板</p><p>honey n.蜜+moon n.月→honeymoon n.蜜月</p></blockquote></li></ul></li></ul></li><li><p><strong>一级派生</strong>：“粘附词根+原生词缀→原始派生词或原生词（Primary Derivative）”</p><ul><li>1）原生前缀+粘附词根→前缀原生词：<blockquote><p>ex-（出）+pend（支付）→expend v.付出</p><p>im-（入）+port（运）→import v.输入</p></blockquote></li><li>2）粘附词根+原生后缀→后缀原生词：<blockquote><p>equ（相等的）+-ate（使……）→equate v.使相等</p><p>vis（看）+-ible（可……的）→visible a.可见的</p></blockquote></li><li>3）原生前缀+粘附词根+原生后缀→前后缀原生词：<blockquote><p>circum-（环绕）+locut（说）+-ion（……方式）→circumlocution n.迂回说法</p><p>im-（不）+pecc（犯罪）+-able+（可……的）→impeccable a.不会做坏事的；没有缺点的</p></blockquote></li></ul></li><li><p><strong>二级派生</strong>：“自由词根+派生词缀→二次派生词（Secondary Derivative）”</p><ul><li>1）派生前缀+自由词根→前缀派生词：<blockquote><p>un-（不）+able a.可能的→unable a.不可能的</p><p>super-（超）+man n.人→superman n.超人</p><p>en-（使）+rich a.富裕的→enrich v.使富裕</p></blockquote></li><li>2）自由词根+派生后缀→后缀派生词：<blockquote><p>man n.人+-less（无……的）→manless a.无人的</p><p>work v.工作+-er（……者）→worker n.工人</p><p>real a.实际的+-ize（使……）→realize v.使实现</p></blockquote></li></ul></li></ul><h2 id="词形变化"><a href="#词形变化" class="headerlink" title="词形变化"></a>词形变化</h2><ul><li><strong>词形变化</strong>： 一般情况下，派生词的词形等于词根与词缀形体的总和。但由于读音的需要或习惯的原因，有些派生词在构词过程中词根与词辍的接合部会发生形态上的变化：字母的增加、字母的脱落、字母的更变及连字符的使用。这些变化大体上有规律可循，认识这些规律，有助于提高词形分析的能力。</li><li><strong>词根音节</strong>：常用英语词根只有单音节与双音节两种，双音节以上的词根极为罕见。从比例来看，单音节词根占80％以上，双音节词根不到20％。从语源来分析：本族语词根中单音节的占90％左右，拉丁词根中单音节的占90％以上，而希腊词根中单音节的比例较低，约占30％左右。</li><li><strong>词根端字母</strong>：<ul><li><strong>单音节</strong>：<ul><li>总的来说，单音节词根的基本模式是：“辅音字母+元音字母+辅音字母”，这里说的字母，包含字母组合，元音字母还包括r音节情况。如：man，vis，log，work，child，fect，phon，therm等词。</li><li>单音节词根中也有少量属“元音字母+辅音字母”模式的，如：act，ann，erg，un等。</li><li>个别词根则以“辅音字母+元音字母”形态出现，如bi，ge，sci等。</li></ul></li><li><strong>双音节</strong>：<ul><li>往往是在单音节词根的模式前后加上元音（包括r音节）。换言之，双音节的词根往往是元音开头或收尾的。例如：anim，imit，ocul，labor，liter，mater等。</li></ul></li></ul></li><li><strong>词根语源</strong>：这方面似无严格的规律可言，只有些可供参考的线索：<ul><li>1）从独立性来看，自由词根多是本族语的，粘附词根多是古典语的；</li><li>2）从字母特征来看，含wr-，th，c（读[s]）等字母或组合的词根是本族语的；含ch（读[k]），j-等字母或组合的词根多是拉丁词根；含ph，gh，rh等字母组合的多是希腊词根。</li></ul></li><li><strong>形态变化</strong>：构词过程中发生的形态变化主要有4种：<ul><li><strong>字母的增加</strong>。字母的增加多发生在词根之后。共有3种情况：<ul><li>1）作为重读闭音节的词根在添加后缀时，音节尾辅音字母需要重写，因而增加了一个辅音字母。<blockquote><p>hap+-en→happen v.发生</p><p>refer+-al→refer.ral a.参考的</p></blockquote></li><li>2）当古典语词根与后缀或另一词根构成一级派生词时，增加连接字母。希腊词根之后多添加-o-，拉丁词根之后多添加-i-。<blockquote><p>helic+-o-+pter→helicopter n.直升飞机</p><p>anthrop+-o-+-logy→anthropology n.人类学</p><p>sent+-i-+-ment→sentiment n.情感；思想感情</p><p>cert+-i-+-fy→certify v.证明；证实</p></blockquote></li><li>3）为了保持某些位于词尾的重读词根中元音字母读长音，在词根后添加无语义的构词后缀-e，使之成为“开音节”。<blockquote><p>in-+clud+-e→include v.包含；包括</p><p>pro-+mot+-e→promote v.促进</p></blockquote></li></ul></li><li><strong>字母的脱落</strong>。主要是词素尾字母的脱落。有两种情况：<ul><li>1）在添加后缀时，某些词根的尾字母-e脱落，以保持词根原来的音值。<blockquote><p>write+-er→writer n.作者</p><p>create+-ive→creative a.创造的</p></blockquote></li><li>2）有些以辅音字母结尾的前缀与以相同的辅音字母开头的词根结合时，前缀尾字母脱落。常见的脱落字母是-s。<blockquote><p>trans-+spir+-e→transpire v.蒸发</p><p>trans-+ship→tranship v.转运</p></blockquote></li></ul></li><li><strong>字母的变更</strong>。字母的变更指在构词过程中，字母（或字母组合）变成另外的字母（或字母组合）。主要有四种情况：<ul><li>1）在零级派生情况下，通过词根内部（而不是接合部）元音字母的变化，使单词的词类发生转化。<blockquote><p> full a.充满的+零派生词缀→fill v.使充满</p><p> food n.食物+零派生词缀→feed v.喂食</p><p> gold n.黄金+零派生词缀→gild v.把……镀金</p></blockquote></li><li>2）在一级派生情况下，某些前缀的尾辅音字母受词根首字母的同化，变得与词根首字母相同。这是拉丁构词规律的遗迹。<blockquote><p>ad-+fect→af.fect</p><p>com-+rect→co.rrect</p><p>dis-+fer→dif.fer</p><p>ex-+fect→ef.fect</p></blockquote></li><li>3）在二级派生情况下，某些拉丁语源的原始派生词的词根尾字母在添加-ion，-ive，-ible等后缀时发生变化。这些变化遵守拉丁词干变化的规律，也是拉丁构词遗留在英语中的痕迹。<blockquote><p>absorb+-ion→absorption</p><p>produce+-ive→productive</p><p>respond+-ible→responsible</p></blockquote></li><li>4）在二级派生情况下，以“辅音字母+y”结尾的单词，在添加派生后缀时，字母y变为i。这是大家熟悉的变化规则。<blockquote><p>dry +-ly→drily</p><p>happy+-ness→happiness</p></blockquote></li></ul></li><li><strong>连字符的使用</strong>。连字符只与自由词根连用，可添加在自由词根之间，也可添加在自由词根与派生词缀之间。主要有5种情况：<ul><li>1）用在临时构成的、尚不稳定的二次派生词与复合词中。<blockquote><p>post-liberation a.解放后</p><p>semi-feudal a.半封建的、</p><p>fox-bat n.狐蝠式战斗机（指米格—25）</p><p>breast-feed v.母乳喂养</p></blockquote></li><li>2）用在某些形似单词的派生词缀上避免误解。<blockquote><p>construction-wise ad.就建筑而言</p><p>ultra-reactionary a.极反动的</p></blockquote></li><li>3）以元音字母结尾的派生前缀与以相同的元音字母开头的单词结合时，使用连字符避免因元音字母双写引起的误读。<blockquote><p>co-operation n.合作</p><p>re-edit v.重编，修订</p></blockquote></li><li>4）用在派生前缀后，避免该二次派生词与同形的外来借词（多为原生词）相混淆。<blockquote><p>re-cover v.重新覆盖</p><p> recover v.发现</p><p> re-create v.再创造</p><p> recreate v.（使）得到消遣</p><p> re-sort v.重新分类</p><p> resort v.求助</p></blockquote></li><li>5）用在前缀与专有名词之间，隔开小写字母与大写字母。<blockquote><p>anti-Yankeeism n.反美国佬主义</p><p>pro-British a.亲英的</p></blockquote></li></ul></li></ul></li></ul><h2 id="词音变化"><a href="#词音变化" class="headerlink" title="词音变化"></a>词音变化</h2><ul><li><strong>词根词音</strong>：词根无论能否独立，均有相对固定的读音，在多数情况下，词根的读音在派生词中保持不变。在派生词中一般是“词根重读、词缀轻读”。但是也有例外情况：有的词缀与词根一起重读，有的词缀能使重读音节转移，有的词缀则会喧宾夺主成为重读音节。如果词根在派生词中重读，其读音保持不变。这时，派生词的读音即等于各种词素读音总和。如果词根是非重读或次重读音节，词根的音值就可能发生变化。从理论上说，构词成分所带的语言信息的主次与读音的重轻应该是一致的。</li><li><strong>词音规律</strong>：<ul><li>1）如果词根在派生词中重读，其读音保持不变。这时，派生词的读音即等于各种词素读音总和。<ul><li>零级派生词：<blockquote><p>firm [fɜ:m]+零原生词缀→firm [fɜ:m] a.结实的</p><p>manu [mænju:]+script [skrɪpt]→manuscript [`mænju:scrɪpt] n.手稿</p></blockquote></li><li>一级派生词：<blockquote><p>trans-[trænz]+fer [fɜ:]→transfer [træns`fɜ:] v.转移，传递</p><p>vis [vɪz]+-ible [ɪbl]→visible [`vɪzɪbəl] a.可见的</p></blockquote></li><li>二级派生词：<blockquote><p>un-[ʌn ]+able [`eɪbl] a.→unable [ʌ`neɪbəl] a.不可能的</p><p>work [wɜ:k]+-er [ə]→worker [`wɜ:kə] n.工人</p></blockquote></li></ul></li><li>2）如果词根是非重读或次重读音节，词根的音值就可能发生变化。这时候，派生词的读音就不完全等于各词素读音的总和。<blockquote><p>differ [`dɪfə]<br>prefer [`prɪfɜ:]<br>preferable [`prefərəbəl]<br>prefer [prɪ`fɜ:]</p></blockquote></li><li>3）“词根重读、词缀轻读”<ul><li>本族语派生词缀构成的二级派生词：<blockquote><p>前缀派生词：a·`bed， for·`get， o·ver·`do， un·der·`stand</p><p>后缀派生词：`child·hood，`clock·wise，`free·dom，`hard·ly，`work·er</p></blockquote></li><li>借用的派生词缀构成的二级派生词：<blockquote><p>前缀派生词：co-`au·thor， de·`rail， in·ter·`cit·y</p><p>后缀派生词：a`maze·ment，`drink·able，`re·al·ize，`slav·ery</p></blockquote></li><li>原生词缀构成的原始派生词：<blockquote><p>前缀原生词：con·`sist， ex·`act， in·`clude， pre·`pare， re·`vise，</p><p>后缀原生词：`a·gent，`sen·ti·ment，`vis·ible，`ac·tive ，`cer·ti·fy</p></blockquote></li></ul></li><li>4）派生词重读中值得注意的例外现象大致有以下7种，4种与前缀有关，3种与后缀有关：<ul><li>1.表示否定意义的派生前缀un-和non-与词根同样重读（这与否定词在句中重读的道理相同）。例如：<blockquote><p>`un·`close，`un·`hap·py，`un·`know，`un·`man；`non·`fic·tion，`non·`hu·man，`non·in·ter`·ven·tion</p></blockquote></li><li>2.双音节的前缀原生词由动词转化成名词或形容词时，重音从词根所在音节（第二音节）转移到词缀所在音节（第一音节）。事实上，这里词缀重读的异常现象是在提醒我们：由于零派生的结果，词类已发生了转化。例如：<blockquote><p>con·`tract v.缔结→`con·tract n.契约</p><p>re·`cord v.记录→`re·cord n.记录，记载</p><p>pro·`gress v. 进步→`pro·gress n.前进</p></blockquote></li><li>3.借用的派生前缀（尤其是拉丁语源的派生前缀），为了表示其有别于同源同形的原生词缀，往往与词根（单词）一起重读。在这种情况下，重读还是轻读往往可以作为区别派生词缀与原生词缀的标志。试比较以下例子中左右两个派生词的词缀读音情况：<blockquote><p>ex·`pand v.张开——`ex·`husband n.前夫</p><p>in·ter·`cept v.拦截——`in·ter·`class a.年级之间的</p><p>pre·`fer v.宁可——`pre·`hu·man a.人类以前的</p><p>pro·`ceed v.进行——`pro-`Ger·ma·ny a.亲德的</p></blockquote></li><li>4.少数前缀在单词中往往重读。比较典型的有post-，self-，semi-等（这些前缀往往也被看成是词根）。例如：<blockquote><p>`post·script，`post·po·`si·tion，`post·`grad·u·ate`self-`care，`self-de·`pend·ence，`self-`praise`sem·i·con·`duc·tor，`sem·i·`month·ly，`sem·i·`lit·er·ate</p></blockquote></li><li>5.个别后缀总是重读，典型的有-ee， -ese，-esque，-ette。例如：<blockquote><p>em·ploy·`ee， ex·am·i·`nee， pay·`ee， ref·u·`gee， Chi·`nese， Japa·`nese， Por·tu·`guese， Vi·en·`nesegro·`tesque， pic·tur·`esque， stat·u·`esque， cig·a·`ertte， kitch·en·`ette， leath·er·`ette</p></blockquote></li><li>6.有些后缀本身并不重读，却会使派生词的重音发生有规则的转移。最有代表性的是-ian， -ic，-ion和-ity，它们总是使单词重音落在自己的前一个音节上。例如：<blockquote><p>`grammar n.语法→gram`·mar·i·an n.语法学家</p><p>`period n.期间→pe·ri`·od·ic a.周期的</p><p>`celebrate n.庆祝→cel·e·`bra·tion n.庆祝活动</p><p>`popular n.普及的→pop·u`·lar·i·ty n.普及</p></blockquote></li><li>7.有些派生词重读的例外现象并无规律可寻，只能把它归因于历史或习惯使然。对这些真正的“捣乱分子”，要特别予以注意。例如：<blockquote><p>`dif·fer，`com·mon，`com·fort等。</p></blockquote></li></ul></li></ul></li></ul><h2 id="词义变化"><a href="#词义变化" class="headerlink" title="词义变化"></a>词义变化</h2><ul><li><strong>词根语义</strong>：由于基本单词反映的是全民族共同活动的基本概念与情境，所以词根的语义也带上了基本单词固有的特点：常用性、稳定性、单一性和能产性。在派生词中，词根提供了主要的语言信息，词缀提供了辅助的语言信息。派生词字面含义与实用词义之间的距离大小（即隐性程度）与参与构词的词根类型有一定的关系。一般说来，由自由词根构成的派生词，词义较显明；由粘附词根构成的派生词，词义较为隐晦。</li><li><strong>词义变化</strong>：<ul><li><strong>显性词</strong>（Transparent Word）：<ul><li>零级派生词（仅举双根词即合成词为例）<blockquote><p>manu (&#x3D;hand)+script (&#x3D;written)→manuscript a. 手抄的 n. 手稿(&#x3D;&lt;sth.&gt;written by hand)</p><p>breast n.+feed v.→breast-feed v. 母乳喂养(to feed a baby with milk from the breast)</p></blockquote></li><li>一级派生词<blockquote><p>pro-(&#x3D;forward)+pel (&#x3D;to push)→propel v.推进(&#x3D;to push forward)</p><p>dormit (&#x3D;to sleep)+-ory (&#x3D;place)→dormitory n.宿舍(&#x3D;place for sleeping)</p><p>hom-(&#x3D;same)+onym (&#x3D;name)+-ous (&#x3D;of)→homonymous a.同名的(&#x3D;of the same name)</p></blockquote></li><li>二级派生词<blockquote><p>pre-(&#x3D;beforehand)+pay v.→prepay v.预付(&#x3D;to pay beforehand)</p><p>home n.+-less (&#x3D;without)→homeless a.无家可归的(&#x3D;without a home)</p></blockquote></li></ul></li><li><strong>隐性词</strong>（Opaque Word）<ul><li>1）由词根与词缀含义综合出的字面含义与派生词的实用意义之间有些距离，需要领会造词意图，才能理解词义。例如（引号中是字面含义）：<blockquote><p>phil-（爱）+anthrop（人类）+-ist（……者）→philanthropist n.（“爱人类者”→）博爱主义者，慈善家</p><p>bi-（两）+cycl（圆环）+-e→bicycle n.（“两个圆环”→“两个轮子的车”→）自行车</p><p>im-（不）+memor（记忆）+-ial（……的）→immemorial a.（“无法追忆的”→）远古的</p><p>ex-（外）+pos（放置）+-e→expose v.（“放在外面”→）暴露，揭露</p><p>de-（离，去）+tect（掩盖）→detect v.（“去掉掩盖”→）发觉，侦查</p></blockquote></li><li>2）由于词义发展的历史，由词根与词缀所决定的派生词的本义在使用过程发生了变化。有的词义扩大，有的缩小，有的扬升，有的贬降，有的则被用于比喻或引申。例如：<blockquote><p>as-（向）+ton（打雷）+-ish（使）→astonish v. 使惊讶 [注：派生词的本义是“使震昏”，现在词义扩大为“使惊讶”。]</p><p>mort（死）+-ify（使……）→mortify v.伤害，侮辱 [注：派生词的本义是“弄死”，现在词义缩小为一般的“伤害”。]</p><p>mar（马）+shal（仆人）→marshal v.元帅 [注：这个原始合成词的本义是“马夫”，后来专指在大典中为皇室引马的人，成了大人物；现在则进一步扬升为“元帅”。]</p><p>dem（人民）+agogue（引导）→demagogue n.蛊惑民心的政客[注：这个原始合成词的本义是“群众领袖”，现在贬降为“蛊惑民心的政客”。]</p><p>avi（鸟飞）+-ation（……动作）→aviation n. 航空 [注：派生词本义是“飞鸟”、“放鸟”，现在引申为“航空”。]</p></blockquote></li><li>3）派生词的词义不但包含了词根和词缀的含义，还包括一定的背景知识。需要了解这些背景，才能理解在特定条件下才能成立的派生词词义。不妨多举几个例子：<blockquote><p>dis-（离）+aster（星）→disaster n.灾祸 [注：派生词字面含义是“偏离轨道的星”，词义却是“灾祸”。这其间带有迷信色彩：古罗马人也是相信星象的。星位不正，便是灾星，意味着大难临头。]</p><p>equ（相等）+-ator（使……者）→equator n.赤道 [注：派生词的字面含义是“使相等者”、“等分者”，词义却是“赤道”。地理常识告诉我们：赤道是等分各条经线的最长的一条纬线。]</p><p>ori（上升）+-ent（……地方）→orient n. 东方 [注：派生词的字面含义是“上升的地方”，词义却是“东方”。古罗马人也把“东方”与“太阳上升的地方”联系一起。]</p><p>sal（盐）+-ary（……物）→salary n.工资 [注：派生词的字面含义是“盐钱”，词义却是“工资”。古罗马时，当兵的食宿都由国家包了，只发一些津贴买调味的盐。“盐钱”便是他们唯一的“工资”。]</p><p>zo（动物）+diac（……的）→zodiac n.黄道带 [注：派生词字面含义是“动物形象的”，词义却是天文上的“黄道带”。原来，中国人称为“黄道十二宫”的天区，古希腊人主要是用动物命名的。]</p><p>febru（赎罪节）+-ary（表事物）→February n.二月 [注：派生词的字面含义是“赎罪的月份”。February是由拉丁文Februar-ius（即菲勃卢姆节）演变而来。这是一个清洁的节日（cleaning day），代表赎罪和净化之意。随着二月的结束，也就是漫长冬季的结束，人们要在这个时期大清扫，表示净化、涤罪，以待春天来临。]</p><p>octo（八）+pus（脚）→octopus n.章鱼 [注：这个原始合成词的字面含义是“八只脚”。你得有些生物学知识，知道章鱼有八只脚。]</p><p>mus（老鼠）+-cle（小……）→muscle n.肌肉 [注：派生词的字面含义是“小老鼠”，词义却是“肌肉”。是古希腊人把两者联在一起。他们在观看竞技运动时，发现运动员上臂的肌肉就像一只小老鼠在皮下不停地跃动。古罗马人接受了这种看法，干脆用“小老鼠”来称呼肌肉。]</p><p>bank（条凳）+rupt（破）→bankrupt n.破产 [注：原始合成词的字面含义是“断了条凳”。这不是普通的条凳，而是兑换货币的商人用来摆放金属货币的台板。台板断了，意味着生意“破产”了。]</p><p>soph（聪明的）+-o-+mor（傻瓜）+-e→sophomore n.大学二年级学生 [注：原始合成词的字面含义是“聪明的傻瓜”。古罗马人用这个词讥笑那些自以为什么都懂的“半桶水”。在他们眼中，“大学二年级的学生”就表现出这种特点。]</p></blockquote></li></ul></li></ul></li></ul><h2 id="词性变化"><a href="#词性变化" class="headerlink" title="词性变化"></a>词性变化</h2><ul><li><strong>词根属性</strong>：英语的粘附词根虽然在形体上不能独立，却依然带有语法属性。词根属性虽不能直接影响派生词的词性，却通过牵制或选择词缀对派生词的词性产生影响。<ul><li>1）自由词根的属性与充当自由词根的基本单词的词性是一致的。例如：<ul><li>在superman（超人）、manhood（成人）中自由词根man的属性即是单词man（人）的词性，所以它是名词性词根。</li><li>在overwork（使工作过度）、worker（工人）中的自由词根work是个动词性词根；</li><li>在badland（荒原）、badly（恶劣地）中bad是个形容词性词根。</li></ul></li><li>2）粘附词根来自古典语基本单词的词干部分，在英语中，它虽然失去了形体上的独立性，却依然保留了原先的语义，可以用一个独立的单词来表达，因此，它也就带有与原先的词性相等的语法属性。例如：<ul><li>拉丁词根ag来自拉丁动词agere的词干部分，语义相当于to love，语法属性亦是动词；</li><li>拉丁词根insul来自拉丁名词insula，意为island，属名词性词根；</li><li>希腊词根dem来自希腊名词demos，意为people，属名词性词根。</li></ul></li></ul></li><li><strong>词性</strong>：英语词缀（尤其是后缀）的语言信息集中反映在语法属性上。词缀的语法属性在派生词内部起作用，与词根构成一定的语法关系，反映在派生词的词性上。所以，词性是词根与词缀语法关系的总和。<ul><li><strong>构词规则</strong>：在派生词内部，词素间的结合必须符合构词规则，这正如句子内部各成分之间的关系要遵守句法规则一样。例如，在短语中，形容词不能修饰形容词，副词不能修饰名词，同样，在派生词内部也不可能产生类似的结合。所以，词素的语法属性首先表现在词素之间互相结合时应遵守语法上的一致性。例如，名词词根可以与动词性、名词性、形容词性以及介词性的词缀结合，却不能与副词性的词缀结合。</li><li><strong>语法属性</strong>：与词根词素一样，词缀词素在构词中既有语义价值又有语法功能。词缀的语义价值在构词过程中表现出来，反映在派生词的词义上；词缀的语法功能在派生词内部起作用，与词根构成一定的语法关系，反映在派生词的词性上。根据词缀的来源与语法功能，可以把它们分为动词性词缀、名词性词缀、修饰性词缀（包括数词性、形容词性、副词性的前缀）和介词性的词缀。词缀在语义上的等值词（或等值词组）可以作为判断其语法属性的标志。<ul><li>前缀en-，后缀-fy在语义上相当于to make，所以都是动词性词缀；</li><li>后缀-ity&#x3D;the quality of，所以是名词性词缀；</li><li>后缀-ful&#x3D;full of，前缀bi-&#x3D;two，un-&#x3D;not，所以都是修饰性词缀；</li><li>前缀inter-&#x3D;between，所以是介词性词缀，等等。</li></ul></li><li><strong>属性结合</strong>：词素之间（互相）结合的过程可以看成是与它们等值的单词或词组按照一定的语法规则组成一个短语的过程。该短语在语义上相当于派生词的字面含义，在语法上与派生词的词性等值。可见，派生词的词性不是靠外部添加语法标志，而是派生词中各词素的语法属性的总和。<ul><li>形容词性的粘附词根ident&#x3D;same，动词后缀-ify&#x3D;to cause to be，名词后缀-ity&#x3D;the quality of，这3个词素可以结合成identify与identity两个派生词。从语义上说，identify&#x3D;to cause to be the same（使同一），identity&#x3D;the quality of being the same（同一性）；从语法上看，ident+-ity&#x3D;形容词+动词，其句法功能相当于动词词组，所以其词性是动词；ident+-ity&#x3D;形容词+名词，其句法功能相当于名词词组，所以其词性是名词。</li></ul></li><li><strong>中心语词</strong>：只要确定在“等值短语”中谁处于中心词或主导词地位，就可以判断出该短语的句法功能。要判断一个派生词的词性，只要确定是哪一个词素在“等值短语”内部的语法关系中处于“中心词”或“主导词”的地位。如果词根词素处于这种地位，它的语法属性就能决定派生词的词性；如果词缀词素处于这种地位，词根只能受其制约，让词缀的属性来决定派生词的词性（这时词根的语法功能只限于对词缀的选择）。<ul><li>在identify与identity中，词根就居于受制约的地位，由后缀的属性决定派生词的词性。相反地，在动词propel（&#x3D;to push forward），名词disaster（&#x3D;an unpleasant star）、形容词 reddish（&#x3D;somewhat red ）中，其词性是分别由词根pel（&#x3D;to push）、aster（&#x3D;star）和red决定的。</li></ul></li></ul></li><li><strong>动词词性</strong>：<ul><li>1）在使用后缀的情况下，后缀以其语法属性与位置制约了词根（即：后缀＞词根），后缀的属性决定了派生词的词性；</li><li>2）在不使用词缀与使用前缀两种情况下，词素间的制约关系以动词、名词、形容词、副词为序（即动词词素＞名词词素＞形容词词素＞副词词素）。应注意，当名词处于中心词位置时，它能制约形容词等修饰语或限定语，而当名词处于宾语（无论是动词还是介词的宾语）位置时，它则受制于动词或介词。因此，动词词根构成动词；名词词根可能构成名词、动词或形容词；形容词词根可能构成形容词或动词。</li></ul></li></ul><h2 id="同源异形"><a href="#同源异形" class="headerlink" title="同源异形"></a>同源异形</h2><ul><li><strong>同源异形现象</strong>：同源异形根现象主要出现于一些拉丁动词词根中。而拉丁动词词根的异形现象，实际上是拉丁动词复杂的变化形式在英语词汇中的遗迹。拉丁语是一种综合性语言。为了语法的需要，拉丁动词有各种变化形式（Conjugation）。为了构成这些变化形式，大多数拉丁动词都有三种动词词干：不定式词干，动名词词干和完成时词干。比如：动词ago（做）的不定式词干是ag，完成时词干是eg，动名词词干是act。拉丁动词异形根的数量多是两个，往往分别来自不定式词干和动名词词干。不过，有时由于某种原因（例如：词根的前身是完成时词干或不规则动词词干，词根是从法语引进的拉丁词干等），异形词根的数量可达两个以上。比如：词根fac（做）就有fact，fect，fic等异形体。</li><li><strong>同源异形的语音解释</strong>：各种尾辅音都向齿龈爆破音[t]过渡；而[t]，[d]则变成破擦清辅音[s]。用式子表示就是：[b]，[p]，[k]，[g] …→[t]；[t]，[d]→[s]。使用这条规则时，要记住在拉丁文中字母c发音为[k]，还要考虑到浊辅音向清辅音[t]过渡时，必要的添音与必然的语音同化现象。</li><li><strong>各种尾辅音都向齿龈爆破音[t]过渡</strong>：<ul><li>1.词根尾辅音字母b→pt<ul><li>1）scrib→script（to write写）</li><li>2）sorb→sorpt（to suck in吸收）</li></ul></li><li>2.词根尾辅音字母p→pt<ul><li>1）cap→capt（to take取）</li><li>2）rap→rapt（to seize 抓）</li></ul></li><li>3.词根尾辅音字母g→ct（字母c发音为[k]）<ul><li>1）ag→act（to do做）</li><li>2）aug→auct（to increase增加）</li><li>3）cing→cinct（to hind阻）</li><li>4）fig→fict（to fashion塑造）</li><li>5）flig→flict（to strike击）</li><li>6）frag→fract（to break破）</li><li>7）frug→fruct（to bear fruit结果实）</li><li>8）leg→lect（to choose选）</li><li>9）pig→pict（to paint油漆）</li><li>10）pung→punct（to pick刺）</li><li>11）reg→rect（to rule划直线，治理）</li><li>12）tag→tact（to touch触）</li><li>13）teg→tect（to cover掩）</li></ul></li><li>4.词根尾辅音字母c→ct（字母c发音为[k]）<ul><li>1）dic→dict（to say说）</li><li>2）doc→doct（to teach教）</li><li>3）duc→duct（to lead引导）</li><li>4）fac→fact（to make做）</li><li>5）sec→sect（to cut切）</li><li>6）spec→spect（to look看）</li><li>7）loqu→locut①（to speak说）</li><li>8）sequ→secut（to follow跟随）</li><li>9）torqu→tort（to twist扭）</li></ul></li><li>5.词根尾辅音字母v→（u）t<ul><li>1）mov→mot（to move运动）</li><li>2）solv→solut（to loosen放松）</li><li>3）volv→volut（to turn转）</li></ul></li><li>6.词根尾辅音字母m→mpt<ul><li>1）em→empt（to buy买）</li><li>2）sum→sumpt（to take and use取用）</li></ul></li><li>7.以 [s] 收尾的词根尾辅音字母或字母组合x，sc→(c)t<ul><li>1）flux→fluct（to flow流）</li><li>2）nasc→nat（to be born出生）</li><li>3）cresc→cret（to grow 生长）</li></ul></li><li>8.其他的词根尾辅音字母→t<ul><li>1）sal→sult（to leap跳跃）</li><li>2）cern→cret（to separate区分）</li><li>3）mon→monit（to remind提醒）</li><li>4）ten→tent（to hold持有）</li><li>5）ger→gest（to carry运）</li><li>6）quer→quest（to ask要求）</li></ul></li></ul></li><li><strong>以t、d收尾的词根变成以s收尾的词根的情况</strong>：<ul><li>9.词根尾辅音字母t→s [s]<ul><li>1）flect→flex（to bend折）</li><li>2）mit→miss（to send发送）</li><li>3）sent→sens（to feel感觉）</li></ul></li><li>10.词根尾辅字母d→s<ul><li>1）cad→cas（to fall降落）</li><li>2）ced→cess（to go行走）</li><li>3）cid→cis（to cut切）</li><li>4）clud→clus（to shut关闭）</li><li>5）fend→fens（to hit打击）</li><li>6）lud→lus（to mock or play耍弄）</li><li>7）mord→mors（to bite咬）</li><li>8）pend→pens（to hang挂；to pay支付）</li><li>9）plaud→plaus（to clap the hands鼓掌）</li><li>10）prehend→prehens（to seize抓）</li><li>11）rad→ras（to scrape 擦）</li><li>12）rid→ris（to laugh笑）</li><li>13）rod→ros（to gnaw or bite咬，蚀）</li><li>14）scand→scans（to climb攀）</li><li>15）tend→tens（to stretch伸展）</li><li>16）trud→trus（to thrust刺）</li><li>17）vad→vas（to go走）</li><li>18）vid→vis（to see看）</li></ul></li></ul></li><li><strong>元音的变化</strong>：在尾辅音发生变化时，词根中的元音和前辅音是很稳定的。不过，也有少数例外的情况。有些词根的异体来自拉丁不规则动词的词干，或者从法语等转引进来，它们的元音也发生了某些变化。一般发生变化的元音是[eɪ]，变化的规则是：[eɪ]→[æ]，[e]，[ɪ]。元音发生变化时，尾辅音也可能同时变化，其变化情况，一般依然符合上面介绍的规则。下面举几个元音发生变化的例子，请注意元音和尾辅音各自变化的特点：<ul><li>1）ascand→ascend, ascens（to climb攀）</li><li>2）cad→cid（to fall落）</li><li>3）cap→cept, cip（to take取）</li><li>4）fac→fect, fic（to make做）</li><li>5）claim→clam（to cry叫喊）</li><li>6）grad→gress（to step迈步）</li><li>7）mand→mend（to order命令）</li></ul></li></ul><h2 id="异源同形"><a href="#异源同形" class="headerlink" title="异源同形"></a>异源同形</h2><ul><li><strong>异源同形现象</strong>：异源同形根现象是“按照词干确定词根形体”这个原则在实际构词中所产生的副产品。异源同形根的前身，在各自的母语中，并不会引起混乱，因为它们往往分属于不同的语种、不同的词性或不同的动词形式，各有特定的形态环境、语义和功能。<ul><li>例一，centipede（蜈蚣）的词根ped1来自拉丁名词pedis，意为foot（足）；pedagogy（教育学）的词根ped2来自希腊名词paidos，意为boy（男孩）。——两者原属不同的语种，词义也不同。</li><li>例二，solitude（孤独）的词根sol1来自拉丁形容词solus，意为alone（单独的）；solar（太阳的）的词根sol2来自拉丁名词sol，意为the sun（太阳）。——两者原属不同的词性，词义也不同。</li><li>例三，elegant（优美）的词根leg1来自拉丁动词legere，意为to choose（挑选）；legal（法律的）的词根leg2来自拉丁名词legis，意为law（法律）。——两者的词性、词义都不同。</li><li>例四，territory（领土）terr1来自拉丁名词 terra，意为 earth（土地），terrible（可怕的）中的terr2来自拉丁动词terrere，意为to frighten（惊吓）。——分属不同的词性，有不同的词义。</li><li>例五，passable（可通行的）的词根pass1来自拉丁名词passius，意为step（步），passible（易受感动的）的词根pass则来自拉丁动词pati的分词词干pass，意为to suffer（受苦）。——两者的词性与词义都不同。</li></ul></li></ul><h2 id="同义词根"><a href="#同义词根" class="headerlink" title="同义词根"></a>同义词根</h2><ul><li><p><strong>同义词根现象</strong>：主要指异源同义词根。英语词汇的三大源头是本族语、拉丁语与希腊语。不同语源都提供了自己的词根，而词根又是表达基本概念的。于是，在英语中存在着十分有趣的现象：许多基本概念都可以用两三种甚至更多的不同语源的词根来表达。从形态上说，几乎每一种基本概念，都可能用单根词（自由词根）与粘附词根两种形式来表示。拉丁词根常构成一般用词，希腊词根常构成科技术语。例如：</p><table><thead><tr><th>含义</th><th>常见词根</th><th>非常见词根</th></tr></thead><tbody><tr><td>天</td><td>sky</td><td>celect</td></tr><tr><td>地</td><td>earth</td><td>ge, terr</td></tr><tr><td>人</td><td>man</td><td>anthrop, vir, dem</td></tr><tr><td>日</td><td>sun</td><td>sol, heli</td></tr><tr><td>月</td><td>moon</td><td>lun, selen</td></tr><tr><td>星</td><td>star</td><td>astro, stell</td></tr><tr><td>生</td><td>life</td><td>bi, anim, viv</td></tr><tr><td>死</td><td>death</td><td>mort</td></tr><tr><td>想</td><td>think</td><td>put</td></tr><tr><td>说</td><td>say</td><td>log, loqu</td></tr><tr><td>做</td><td>do</td><td>act</td></tr><tr><td>头</td><td>head</td><td>cephal, capit</td></tr><tr><td>手</td><td>hand</td><td>manu, cheir</td></tr><tr><td>脚</td><td>foot</td><td>ped, pod</td></tr><tr><td>声</td><td>sound</td><td>phon, ton, son</td></tr><tr><td>光</td><td>light</td><td>phot, luc</td></tr><tr><td>力</td><td>power</td><td>dyn, sthen</td></tr><tr><td>热</td><td>heat</td><td>therm</td></tr><tr><td>金</td><td>gold</td><td>aur, chrys</td></tr><tr><td>木</td><td>wood</td><td>lign, xyl, arbor</td></tr><tr><td>水</td><td>water</td><td>hydr, aqu</td></tr><tr><td>火</td><td>fire</td><td>ign, pyr</td></tr></tbody></table></li></ul><h2 id="多义词根"><a href="#多义词根" class="headerlink" title="多义词根"></a>多义词根</h2><ul><li><strong>多义词根现象</strong>：有些词根是多义的。这主要是拉丁动词词根，而且为数不多。拉丁动词词根表达的多是基本的行为，一般情况下，它们的含义是单纯的。少数拉丁动词词根的含义在用英语或汉语表达含义时出现多义现象，主要有几个原因。<ul><li>1）词根在拉丁语中有转义或引申义：这些含义的派生词都成为英语中的借词，因而表现出词根的多义。<blockquote><p>动词词根pend，pens原意是 to hang（悬挂），由于把东西挂在天平上才能称量，所以又有 to weigh（称量）的含义，又因为用天平称量金银来付款，又多了个to pay（支付）的含义。这3个含义的派生词都进入英语。所以，我们发现在depend（依靠），suspend（吊悬）、pendulum（悬摆）中pend 意为“悬挂”，在dispense（分配），compensate（补偿）中pens意为“称量”，在expend（付出），spend（消耗）中，pend意为“支付”。</p></blockquote></li><li>2）词根本身有不同的意思：<blockquote><p>词根ag，act 既有to do（做）的意思，也有“驱使他人去做”的to drive（驱使）之意。例如：在react（反动）中act意为to do，在exact（强求）中act意为to drive。</p></blockquote></li><li>3）词根的意思需要用不同的英语单词表达：<blockquote><p>词根fer表示“负重移动”的意思，在英语中用to bear（负担），to carry（持），to bring（带来）等近义词，才能较为准确地表达出它在派生词中的含义。例如，在suffer（忍受）中词根fer意为to bear，在transfer（转移）中fer意为to carry；在confer（协商）中fer意为to bring。</p></blockquote></li></ul></li></ul><h2 id="多层派生"><a href="#多层派生" class="headerlink" title="多层派生"></a>多层派生</h2><ul><li><strong>多层派生词的构词顺序问题</strong>：确定多层派生构词的顺序，牵涉到词形分析、词义理解、甚至词性判断的问题。例如，上面提到的unmasked这个单词可能是按照两种不同的顺序经过两次派生而成的。构词顺序不同，结果也不一样：<ul><li><p><strong>以多层派生词unmasked为例</strong>：</p><blockquote><p>其一：mask v.戴面具+-ed（被……的）→masked a.戴面具的→un-（不）+ masked a.戴面具的→unmasked1 a.不戴面具的</p><p>其二：un-（除去……）+mask n.面具→unmask v.撕下……的假面具→unmask v.撕下……的假面具+-ed（被……的）→unmasked2 a.被撕下假面具的；被揭露的</p></blockquote></li><li><p><strong>以多层派生词unfriendliness为例</strong>：事实上，只有第三种构词顺序是正确的。第一种顺序错在副词性的前缀un-（&#x3D;not）不能加在名词friendiness上。第二种顺序错在不存在unfriend这个单词，其原因也是名词friend不能与副词性前缀un-（&#x3D;not）结合。可见，词根对词缀的词性是有选择的。派生构词并非随意可行，它必须遵守一定的规则。</p><blockquote><ol><li><p>friend→friendly→friendliness→unfriendliness</p></li><li><p>friend→unfriend→unfriendly→unfriendliness</p></li><li><p>friend→friendly→unfriendly→unfriendliness</p></li></ol></blockquote></li><li><p><strong>其他例子</strong>：用几个较为复杂的长单词做一番实验。为了节省篇幅，使用括号、方括号与括弓表示从内到外的派生构词顺序：</p><blockquote><p>invisible&#x3D;in-+(vis+-ible)</p><p>importer&#x3D;(im-+port)+-er</p><p>unprecedented&#x3D;un-+[(pre-+ced+-ent)+-ed]</p><p>unfriendliness&#x3D;[un-+(friend n.+-ly)]+-ness</p><p>depolarization&#x3D;{de-+[(pol+-ar)+-ize]}+-ation</p><p>anti-nationalization&#x3D;anti-+{[(nation n.+-al)+-ize]+-ation}</p><p>unsaddled1 a.未上鞍的&#x3D;un-+(saddle v.+-ed)</p><p>unsaddled2 a.卸了鞍的&#x3D;(un-+saddle n.)+-ed</p></blockquote></li></ul></li></ul><h2 id="词根-单根词"><a href="#词根-单根词" class="headerlink" title="词根&amp;单根词"></a>词根&amp;单根词</h2><ul><li><p><strong>词根与单根词的判断问题</strong>：在英语词汇中有部分单词根（即只含有一个词根的零级派生词）与词根同形。有的单根词的词义与词根的意义相同或相近，有的却相去甚远。由于词根不能作为语法形态独立出现在句子中，在句子中出现的一定是与词根同形的单根词。在这种情况下，两者之间不可能混淆，也不存在判断的问题。问题在于，单根词与词根都可能与另一词素（主要是词缀）相结合，构成派生词。这时，就可能需要判断这个派生词到底是由“词根+原生词缀”构成的一级派生词，还是由“单根词+派生词缀”构成的二级派生词。</p><table><thead><tr><th>单根词</th><th>词根</th></tr></thead><tbody><tr><td>act n.行为 v.行动</td><td>act“做”</td></tr><tr><td>arm n.武器</td><td>arm“武装”</td></tr><tr><td>art n.艺术</td><td>art“技艺”</td></tr><tr><td>claim v.要求，索取</td><td>claim“喊”</td></tr><tr><td>fact n.事实</td><td>fact“做”</td></tr><tr><td>firm a.结实的，牢固的</td><td>firm“固定的”</td></tr><tr><td>form n.形状；形式</td><td>form“形成”</td></tr><tr><td>miss v.未击中，错过</td><td>miss“发”，“送”</td></tr><tr><td>mount n.山 v.登山</td><td>mount“山”</td></tr><tr><td>norm n.标准规范，准则</td><td>norm“规则”</td></tr><tr><td>part n.部分，局部</td><td>part“部分”</td></tr><tr><td>port n.姿势，姿态；港口</td><td>port“拿”，“运”</td></tr><tr><td>press v.按，压，挤</td><td>press“压”</td></tr></tbody></table></li><li><p><strong>判断方法</strong>：</p><ul><li>1）<strong>判断词缀的属性</strong>：与派生词缀构词的是单根词，与原生词缀结合的是词根。<blockquote><p>act v.扮演+-able a.“能……的”→actable a.能演出的</p><p>act v.扮演+-ing n.“表行为”→acting n.表演；演技</p><p>en-“使置于……”+act n.法令→enact v.制定、颁布（法律）</p><p>over-“太……”+act v.表演→overact v.演得过于夸张</p><p>act“做”+-ion n.“表行为”→action n.行为；行动过程</p><p>act“做”+-ive a.“表特征”→active n.活跃的，积极的</p><p>ex-“出”+act“做”→exact a.严厉的；准确的</p><p>re-“回”+act“做”→react v.反应；反动</p><p>trans-“穿过”+act“做”→transact v.执行，办理；交易</p></blockquote></li><li>2）<strong>判断派生词词义的来源</strong>：当词根含义与单根词含义有一定距离时，可以试分析派生词的词义是从单根词引出，还是从词根引出。读者对单根词较为熟悉，如果以单根词词义去分析派生词词义行不通时，就应当考虑词根的可能性。<blockquote><p>例如，读者大多知道port的词义是“港口”，但用“港口”来分析portable（可携带的），report（报告），support（支持），disport（玩耍）等单词，显然行不通。这时，就应该考虑port是词根，其含义是“to carry（拿、运）”。</p></blockquote></li><li>3）<strong>还可以利用“单词根不存在形态变化，词根可能有异体”这个特点进行间接的判断</strong>：<blockquote><p>例如，claim有个异体clam。据此，我们可以判断 claimer，claimable，disclaimer中的 claim 是单根词，而 clamour（呼声）中clam是词根。同样，可以判断declaim中的claim是词根，因为它的二次派生词为declamation，词根是clam。</p></blockquote></li></ul></li></ul><h2 id="学术词缀"><a href="#学术词缀" class="headerlink" title="学术词缀"></a>学术词缀</h2><ul><li><strong>词根与术语词缀的界定问题</strong>：研究词根，不能不提到一种与词根关系密切的词缀，即术语词缀（Terminological Affix）。其实，术语词缀是从词根演变来的，演变以后，就突破了古典语构词的限制，大大增强了孳生能力。所以，有人将术语词缀称为“能产型的粘附词根”。前面说过，词缀是一种粘附词素，必须依附于词根才能构词。但是，术语词缀却有一个非常特殊的功能，即一个术语前缀可以与一个术语后缀构成一个带术语性质的单词。例如：<blockquote><p>chrono-（时间）+-graph（记录器）→chronograph n.记时器</p><p>aero-（空气）+-logy（……学）→aerology n.气象学</p><p>thermo-（热）+-stat（稳定器）→thermostat n.恒温计</p></blockquote></li><li><strong>区分方法</strong>：<ul><li>从形态上看。词根可能有异体存在，如aer的异体有ar，air等，而术语词缀aero-的形态单一。词根前后并无固定的连接字母，术语前缀后面往往有连接字母-o-或-i-，如：bio-，thermo-，denti-（齿）等。词根在词典中一般查不到，术语词缀则为许多词典，尤其是专业词典所收录。</li><li>从含义上看。词根表达的多是一般意义，可以构成不同类型的单词。术语词缀的意义则较为专门与固定，往往构成科技术语。例如：graph 作为词根，意思为“写”，可以构成 graphics（制图法），monograph（专题文章），paragraph（段落）等一般词汇；而-graph作为术语后缀，只能表示“书写材料、记录器”的意思。</li><li>从位置上看。词根的位置比较灵活，它可以与词缀结合，位于派生词的前位，末位，或中位。术语词缀的位置则相对固定。在一次派生词中，术语前缀只能位于词首，术语后缀只能位于词尾。例如；词根log (ue)（讲），在logic（逻辑）中处于词首，在dialogue（对话）中处于词尾，在apologize（道歉）中处于词中；而同根的术语后缀-logy（……学），只能位于词尾。</li></ul></li></ul><p>[1] 李平武, 英语词根与单词的说文解字. 外语教学与研究出版社, 2008.<a href="https://books.google.com.tw/books/about/%E8%8B%B1%E8%AF%AD%E8%AF%8D%E6%A0%B9%E4%B8%8E%E5%8D%95%E8%AF%8D%E7%9A%84%E8%AF%B4%E6%96%87%E8%A7%A3%E5%AD%97.html?id=xFquQQAACAAJ&redir_esc=y">Book</a></p>]]></content>
    
    
    <summary type="html">为什么英文单词不像中文汉字有规律？你可能需要知道一下English词素构词理论。</summary>
    
    
    
    <category term="Know" scheme="https://zhoufenmianfan.github.io/categories/Know/"/>
    
    
    <category term="English" scheme="https://zhoufenmianfan.github.io/tags/English/"/>
    
  </entry>
  
  <entry>
    <title>总结：PC组件相关知识</title>
    <link href="https://zhoufenmianfan.github.io/2024/01/07/PC%E7%BB%84%E4%BB%B6%E7%9F%A5%E8%AF%86/"/>
    <id>https://zhoufenmianfan.github.io/2024/01/07/PC%E7%BB%84%E4%BB%B6%E7%9F%A5%E8%AF%86/</id>
    <published>2024-01-07T07:56:00.000Z</published>
    <updated>2024-01-11T12:40:26.246Z</updated>
    
    <content type="html"><![CDATA[<h2 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h2><ul><li><strong>主要部件</strong>：<ul><li><strong>CPU</strong>：大脑，计算机核心</li><li><strong>主板</strong>：躯干，包含各种组件的物理支撑和接口提供，主板的主要功能是提供一系列接合点，形成一个能集成处理器、内存、存储设备（硬盘、固态驱动器、闪存等）、显卡、声卡、网卡和各种外部设备的连接平台。</li><li><strong>内存</strong>：演算“草稿纸”，数据提交CPU的中转站</li><li><strong>显卡</strong>：第二大脑，专用于图形处理。是一种专门在个人电脑、工作站、游戏机和一些移动设备（如平板电脑、智能手机等）上执行绘图运算工作的微处理器。以图形处理器为核心的主板扩展卡也称显示卡或“显卡”。</li><li><strong>硬盘</strong>：知识存储区域<ul><li>固态：</li><li>机械：</li></ul></li><li><strong>散热</strong>：有多个结构，CPU散热、显卡散热、内存散热、硬盘散热等需要散热的地方</li><li><strong>电源</strong>：能量分配。供电单元（power supply unit，PSU），又被称作电源供应器或电源供应单元，是电能转换类的电源（有别于电池供电类的电源），主要功能为将标准交流电转成低压稳定的直流电，或直接将直流电转成低压稳定的直流电给某些特殊的器材使用。</li></ul></li><li><strong>机箱</strong>：支撑结构</li><li><strong>总线与接口</strong>：数据运输方案，连接结构。总线（Bus）是指计算机组件间规范化的交换数据（data）的方式，即以一种通用的方式为各组件提供数据传送和控制逻辑。从另一个角度来看，如果说主板（Mother Board）是一座城市，那么总线就像是城市里的公共汽车（bus），能按照固定行车路线，传输来回不停运作的比特（bit）。这些线路在同一时间内都仅能负责传输一个比特。因此，必须同时采用多条线路才能发送更多资料，而总线可同时传输的资料数就称为宽度（width），以比特为单位，总线宽度愈大，传输性能就愈佳。总线的带宽（即单位时间内可以传输的总资料数）为：总线带宽 &#x3D; 频率×宽度（Bytes&#x2F;sec）。</li></ul><h2 id="中央处理器（CPU）"><a href="#中央处理器（CPU）" class="headerlink" title="中央处理器（CPU）"></a>中央处理器（CPU）</h2><ul><li><p><strong>主要参数</strong>：</p><ul><li><p><strong>频率</strong>：处理数据的速度，<a href="https://vika.cn/workbench/dst4G3GSjFXXvuCC9P/viw43dQ3GVDHk/rec7gNsWY6LOu">时钟频率</a></p><ul><li>主频：正常轻度使用电脑时cpu工作频率</li><li>睿频：是英特尔的对其中央处理器（CPU）的时钟频率自动加速技术的商业名称。当程序对CPU资源利用增加时，睿频加速技术自动开启，提高CPU频率，以满足算力需求。</li><li>超频：是把电子配件的时脉速度提升至高于厂方所定的速度运作，从而提升性能的方法，但此举有可能导致该配件稳定性下降。</li></ul></li><li><p><strong>架构</strong>：</p><ul><li><p><strong>指令集架构</strong>：是计算机体系结构中与程序设计有关的部分，包含了基本数据类型，指令集，寄存器，寻址模式，存储体系，中断，异常处理以及外部I&#x2F;O。指令集架构包含一系列的opcode即操作码（机器语言），以及由特定处理器执行的基本命令。不同的处理器“家族”有不同的指令集架构。使用不同微架构的电脑可以共享一种指令集。</p><ul><li><p><strong>精简指令集计算机</strong>：（英语：Reduced Instruction Set Computer，缩写：<strong>RISC</strong>）或简译为精简指令集。是计算机中央处理器的一种设计模式。这种设计思路可以想像成是一家模块化的组装工厂，对指令数目和寻址方式都做了精简，使其实现更容易，指令并行执行程度更好，编译器的效率更高。</p></li><li><p><strong>复杂指令集计算机</strong>：（英文：Complex Instruction Set Computer；缩写：<strong>CISC</strong>）是一种微处理器指令集架构，每个指令可执行若干低端操作，诸如从存储器读取、存储、和计算操作，全部集于单一指令之中。与之相对的是精简指令集。</p><p>复杂指令集的特点是指令数目多而复杂，每条指令字长并不相等，电脑必须加以判读，并为此付出了性能的代价。</p></li></ul><p><strong>与复杂指令集相比，精简指令集实现更容易，指令并行执行程度更好，编译器的效率更高。</strong></p><ul><li><strong>寄存器（Register）</strong>：是中央处理器内用来暂存指令、数据和地址的电脑存储器。寄存器的存贮容量有限，读写速度非常快。在计算机体系结构里，寄存器存储在已知时间点所作计算的中间结果，通过快速地访问数据来加速计算机程序的执行。</li></ul></li><li><p><strong>微架构</strong>：微架构包含处理器内部的构成以及这些构成起来的部分如何执行指令集架构。微架构通常被表示成流程图，以描述机器内部组件的链接状况，从一个闸或是寄存器，到算术逻辑单元（ALU）。图上分布着资料路径（可以显示资料在微架构的位置）以及控制路径（显示资料该被什么指令所处理）。</p></li></ul></li><li><p><strong>位数</strong>：CPU数字表示方法是一个设计上的选择，这个选择影响了设备的工作方式。几乎所有的现代的CPU使用二进制系统来表示数字，这样数字可以用具有两个值的物理量来表示，例如高低电平等等。更高的整数精度需要更多线路以支持更多的数字比特，也因此结构更复杂、更巨大、更花费能源，也通常更昂贵。因此尽管市面上有许多更高精准度的CPU（如16，32，64甚至128位），但依然可见应用软件执行在4或8位的微控制器上。越简单的微控制器通常较便宜，花费较少能源，也因此产生较少热量。这些都是设计电子设备的主要考量。</p></li><li><p><strong>核心</strong>：1970年代以前，中央处理器由多个独立单元构成，后来发展出由集成电路制造的中央处理器，这些高度收缩的器件就是所谓的微处理器，其中分出的中央处理器最为复杂的电路可以做成单一微小功能强大的单元，也就是所谓的<strong>核心</strong>。多核心中央处理器是在中央处理器芯片或封装中包含多个处理器核心，以偶数为核心数目较为常见，一般共享二级缓存。</p><p>一般来说，并不是所有任务都会调用所有核心，有时候一个进程计算量很大，但是却只会调用一个最近的核心进行工作，所以就会造成看起来仍然“速度慢”的现象，即“<strong>一核有难，八核围观</strong>”。</p></li><li><p><strong>线程</strong>：一个核心管控若干个线程（一般只有两个线程），在同一时刻，一个核心可以同时进行它所管控的线程的的进程，这样就最大化利用核心的性能。</p></li><li><p><strong>缓存</strong>：<strong>CPU高速缓存</strong>，是用于减少处理器访问内存所需平均时间的部件。在金字塔式存储体系中它位于自顶向下的第二层，仅次于CPU寄存器。其容量远小于内存，但速度却可以接近处理器的频率。</p></li></ul></li><li><p><strong>生产厂商</strong>：（两大厂N小厂）Intel 和 AMD</p><ul><li><p><strong>Intel</strong>：英特尔（英语：Intel Corporation），是世界上第二大的半导体公司</p><ul><li><p><strong>主要产品</strong>：中央处理器（CPU）、微控制器、图形处理器、电脑存储器、闪存、固态硬盘及其主控、主板及其芯片组、网络接口卡、蓝牙芯片、移动电话调制解调器（已被苹果公司收购）、晶圆代工服务。</p></li><li><p>CPU产品线：</p><ul><li>Core：酷睿，主流产品</li><li>Celeron：赛扬</li><li>Pentium：奔腾</li></ul></li><li><p><strong>CPU命名规则</strong>：以Core为例</p></li></ul></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Zhoufenmianfan/images/main/202401112037120.png"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p><ul><li><p><strong>AMD</strong>：超威半导体公司（英语：Advanced Micro Devices, Inc.；缩写：AMD），简称超威或超微，是美国一家专注于微处理器及相关技术设计的跨国公司，</p><ul><li><p>主要产品：中央处理器、微处理器、主板芯片组、图形处理器、内存、电视调谐卡</p></li><li><p><strong>CPU命名规则</strong>：以R U为例</p></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Zhoufenmianfan/images/main/202401112038607.png"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p><ul><li><strong>CPU天梯图</strong>：用于衡量CPU性能的一个纵向分布图，由个人或组织绘制，例如：<a href="https://www.mydrivers.com/zhuanti/tianti/cpu/index.html">https://www.mydrivers.com/zhuanti/tianti/cpu/index.html</a></li></ul><h2 id="随机存取存储器（内存）"><a href="#随机存取存储器（内存）" class="headerlink" title="随机存取存储器（内存）"></a>随机存取存储器（内存）</h2><ul><li><strong>主要参数</strong>：<ul><li><strong>存储技术</strong>：由于晶体管会有漏电流的现象，导致电容上所存储的电荷数量并不足以正确的判别数据，进而导致数据毁损。因此对于DRAM来说，周期性地充电是一个不可避免的条件。由于这种需要定时刷新的特性，因此被称为“动态”存储器。相对来说，静态存储器（SRAM）只要存入数据后，即使不刷新也不会丢失记忆。<ul><li><strong>SRAM</strong>：静态随机存取存储器</li><li><strong>DRAM</strong>：动态随机存取存储器<ul><li><strong>SDRAM</strong>：同步动态随机存取存储器，是一种利用同步计时器对存储器的输出入信号加以控制的动态随机存取存储器（DRAM）。SDRAM是在DRAM的架构基础上增加同步和双区域（Dual Bank）的功能，使得微处理器能与SDRAM的时钟同步，所以SDRAM执行命令和传输资料时相较于DRAM可以节省更多时间。<strong>DDR系列都是这一系列的存储器</strong>。</li></ul></li></ul></li><li><strong>存储器墙</strong>：“存储器墙”是指CPU与CPU芯片外的存储器之间的速度差距越来越大，其中一个造成差距的重要原因是芯片边界之外的通信带宽有限，又称为带宽墙。</li><li><strong>内存容量</strong>：存储器能够存储的数据量大小。</li><li><strong>频率</strong>：单位时间内读写数据的次数。</li><li><strong>时序</strong>：即内存读写延迟</li><li><strong>颗粒</strong>：制作内存使用的材料，决定了内存性能的上限</li><li><strong>SPD</strong>：由于个人计算机运行前，需要提前获知内存设备的一些信息，因此有了SPD。SPD是内存模组上面的一个可擦写的eeprom，里面记录了该内存的许多重要信息，诸如内存的芯片及模组厂商、工作频率、工作电压、速度、容量、电压与行、列地址带宽等参数。SPD信息一般都是在出厂前，由内存模组制造商根据内存芯片的实际性能写入到eeprom芯片中。</li><li><strong>XMP</strong>：内存厂商为了更好的适配性，让内存条可以工作在不同的频率环境下，于是设置了XMP这种开关。众所周知，内存条可以工作在其默认频率之上。内存的预设频率并不高，这样是为了其产品稳定。游戏玩家可以将其频率提升，从而提升性能。</li></ul></li></ul><h2 id="存储驱动器（硬盘）"><a href="#存储驱动器（硬盘）" class="headerlink" title="存储驱动器（硬盘）"></a>存储驱动器（硬盘）</h2><p>📌现在有了固态驱动器，但是习惯上还是称其为“固态硬盘”。</p><ul><li><p><strong>主要参数</strong>：</p><ul><li><strong>分类</strong>：<ul><li><strong>机械硬盘</strong>：硬盘驱动器、（英语：Hard Disk Drive，缩写：HDD），简称硬盘（hard disk）或硬驱（hard drive），又称“传统硬盘”。<ul><li><strong>接口</strong>：机械硬盘按数据接口不同，大致分为<a href="https://zh.wikipedia.org/wiki/%E9%AB%98%E6%8A%80%E8%A1%93%E9%85%8D%E7%BD%AE">ATA</a>（又称<a href="https://zh.wikipedia.org/wiki/%E9%9B%86%E6%88%90%E8%AE%BE%E5%A4%87%E7%94%B5%E8%B7%AF">IDE</a>）和<a href="https://zh.wikipedia.org/wiki/SATA">SATA</a>以及<a href="https://zh.wikipedia.org/wiki/SCSI">SCSI</a>和<a href="https://zh.wikipedia.org/wiki/%E4%B8%B2%E5%88%97SCSI">SAS</a>。</li><li><strong>尺寸</strong>：3.5英寸，多用于台式机中。但采用3.5”硬盘的外置硬盘盒一般都需外接电源，因为耗电量超过USB的供电上限，且3.5寸硬盘需要12v电压。2.5英寸，多用于笔记本电脑及外置硬盘盒中。采用2.5寸硬盘的外置硬盘盒一般不需外接电源。此外还有各种其他尺寸。</li><li><strong>转速</strong>：硬盘每分钟旋转的圈数，单位是rpm（Revolutions Per Minute，每分钟的转动数），一般来讲转速愈高通常资料传输速率愈好，但同时噪音、耗电量和发热量也越高。</li><li><strong>容量</strong>：硬盘最主要的参数，存储的数据量大小。</li><li>缓存：硬盘读写的临时存储数据区域。</li><li><strong>内部传输速度</strong>：包括磁头把数据从盘片读入缓存的速度，以及磁头把数据从缓存写入盘片的速度。可用来评价硬盘的读写速度和整体性能。</li><li><strong>平均寻道时间</strong>：单位是ms（毫秒），有5.2ms、8.5ms、8.9ms、12ms等。</li></ul></li><li><strong>固态硬盘</strong>：固态驱动器（英语：Solid-state drive或Solid-state disk，简称SSD）是一种以集成电路制作的电脑存储设备，虽然价格及存储容量与机械硬盘有少许差距，但固态硬盘读取的速度可比机械式硬盘的快200倍。<ul><li><strong>接口</strong>：固态硬盘常采用<a href="https://zh.wikipedia.org/wiki/SATA">SATA</a>、<a href="https://zh.wikipedia.org/wiki/PCI_Express">PCI Express</a>、<a href="https://zh.wikipedia.org/wiki/MSATA">mSATA</a>、<a href="https://zh.wikipedia.org/wiki/M.2">M.2</a>、<a href="https://zh.wikipedia.org/wiki/ZIF">ZIF</a>、<a href="https://zh.wikipedia.org/wiki/%E9%AB%98%E6%8A%80%E8%A1%93%E9%85%8D%E7%BD%AE">IDE</a>、<a href="https://zh.wikipedia.org/wiki/U.2">U.2</a>、<a href="https://zh.wikipedia.org/wiki/CompactFlash">CF</a>、<a href="https://zh.wikipedia.org/w/index.php?title=CFast&action=edit&redlink=1">CFast</a>等接口。</li><li><strong>易失性存储器</strong>：由易失性存储器制成的固态硬盘主要用于临时性存储（例如 I-RAM）。由易失性存储器制成的固态硬盘可能可以搭配电池使用：当关机或电源意外中断时，这类固态硬盘可以靠电池驱动持续记忆资料，当电力恢复后，再将资料转移到永久性存储设备。</li><li><strong>非易失性存储器</strong>：和易失性存储器相比，非易失性存储器一经写入资料，就不需要外界电力来维持其记忆。因此更适于作为传统硬盘的替代品。<ul><li>NAND Flash架构：随着生产成本的下降，将多个大容量闪存模块集成在一起，制成以闪存为存储介质的固态硬盘已经是目前的趋势。目前用来生产固态硬盘的<a href="https://zh.wikipedia.org/wiki/%E9%97%AA%E5%AD%98#NAND_Flash">NAND Flash</a>有四种，分别是单层式存储（<a href="https://zh.wikipedia.org/wiki/%E9%97%AA%E5%AD%98#SLC">SLC</a>）、多层式存储（<a href="https://zh.wikipedia.org/wiki/%E9%97%AA%E5%AD%98#MLC">MLC</a>，通常用来指称双层式存储）、三层式存储（<a href="https://zh.wikipedia.org/wiki/%E9%97%AA%E5%AD%98#TLC">TLC</a>）、四层式存储（<a href="https://zh.wikipedia.org/wiki/%E9%97%AA%E5%AD%98#QLC">QLC</a>）。</li></ul></li></ul></li></ul></li></ul></li><li><p><strong>📌资料损失</strong>：固态硬盘数据损坏后是难以修复救回资料的。当负责存储资料的闪存颗粒有毁损时，现在的数据修复技术很难在损坏的半导体芯片中救回资料，相反传统机械硬盘还能通过扇区恢复技术挽回许多资料，当然机械硬盘的数据救回服务收费极度高昂，通常只有企业在挽救重要价值资料时会使用。虽然逐渐有厂商开发SSD轻度损坏时的救援方法，但传统的多存储介质备份习惯还是万全之法，不论是机械碟或SSD只要无备份习惯都将承受资料损失的风险。</p></li></ul><h2 id="主板"><a href="#主板" class="headerlink" title="主板"></a>主板</h2><ul><li><p><strong>主要参数</strong>：</p><ul><li><p><strong>插槽</strong>：可以直接插入扩展卡的插槽</p></li><li><p><strong>芯片组</strong>：指的是一类由好几个微芯片组合而成的完整芯片，它负责将电脑的处理器和和其它部分做连接，以便能互传数据。<strong>芯片组为主板提供一个通用平台供不同设备连接，控制不同设备的沟通。</strong>芯片组先是从2000年代开始简化为南桥和北桥两颗芯片，再于2010年代简化为单独一颗的<strong>南桥芯片</strong>，目前世界上的芯片组均以单一的南桥芯片为主流。芯片组亦为主板提供额外功能，例如内置于芯片组的GPU。</p><ul><li><strong>北桥</strong>：是基于Intel处理器的个人电脑主板芯片组两枚芯片中的一枚，北桥用来处理高速信号，例如中央处理器、存储器、集成式GPU、高速总线（如PCI Express接口或AGP接口）控制器，还有与南桥之间的通信。之后所有Intel与AMD的主板仅有南桥，北桥已集成到CPU。</li><li><strong>南桥</strong>：是基于个人电脑主板芯片组架构中的其中一枚芯片。南桥设计用来处理低速信号，通过北桥与中央处理器联系。各芯片组厂商的南桥名称都有所不同，例如英特尔称之为<a href="https://zh.wikipedia.org/wiki/I/O%E8%B7%AF%E5%BE%91%E6%8E%A7%E5%88%B6%E5%99%A8">I&#x2F;O路径控制器</a>（ICH）或<a href="https://zh.wikipedia.org/wiki/%E5%B9%B3%E5%8F%B0%E8%B7%AF%E5%BE%91%E6%8E%A7%E5%88%B6%E5%99%A8">平台路径控制器</a>（PCH），NVIDIA的称为MCP，ATI的称为IXP&#x2F;SB，AMD用<a href="https://zh.wikipedia.org/wiki/AMD_FCH">FCH</a>（Fusion Control Hub）代表<a href="https://zh.wikipedia.org/wiki/AMD_APU">AMD APU</a>&#x2F;<a href="https://zh.wikipedia.org/wiki/AMD_Ryzen">AMD Ryzen</a>&#x2F;<a href="https://zh.wikipedia.org/wiki/EPYC">AMD EPYC</a>的南桥芯片。</li></ul></li><li><p><strong>温度可靠</strong>：主板一般会使用散热片给芯片组和CPU散热，在以前这种被动散热方式可以满足需求。直到1990年，因为处理器的频率提升以及功率上升，所以CPU散热器需要挂载风扇以满足散热需求。除此之外，也有机壳的风扇帮助散热。现在的主板集成了温度传感器，用于侦测CPU等设备的温度，透过BIOS或是操作系统分析温度变化以控制风扇的转动速度。</p></li><li><p><strong>BIOS</strong>：电脑从关机状态启动，则必须执行<strong>初始化的软件指令</strong>。BIOS（英文：Basic Input&#x2F;Output System），即基本输入输出系统，亦称为ROM BIOS、System BIOS、PC BIOS，是在通电启动阶段执行硬件初始化，以及为操作系统提供运行时服务的固件。大部分的主板的BIOS存储在<a href="https://zh.wikipedia.org/wiki/Flash">Flash</a> <a href="https://zh.wikipedia.org/wiki/ROM">ROM</a>芯片内，用于对主板作启动的初始化；在启动的过程中包含存储器、周边设备都会被测试以及做初始设置，这个过程称为 <a href="https://zh.wikipedia.org/wiki/%E5%8A%A0%E7%94%B5%E8%87%AA%E6%A3%80">加电自检</a>（<a href="https://zh.wikipedia.org/wiki/POST">POST</a>），若是在 POST 的过程中出现错误，则主机会发出”哔”声或是出现错误消息在屏幕上。</p></li><li><p><strong>CPU插座</strong>：不同CPU系列使用不同插槽。后期CPU插槽，数字多数与针脚数量相同。前期CPU插槽则根据问世次序命名。</p></li><li><p><strong>扩展插槽</strong>：主板通常有数条插槽供扩展之用。</p></li><li><p><strong>外部接口</strong>：用于连接外部可插拔设备。</p></li><li><p><strong>主板规格</strong>：不同主板规格有不同功用，所以大小也有不同。现时常用<a href="https://zh.wikipedia.org/wiki/ATX%E8%A6%8F%E6%A0%BC">ATX</a>、<a href="https://zh.wikipedia.org/wiki/MicroATX">MicroATX</a>、<a href="https://zh.wikipedia.org/wiki/Mini-ITX">Mini-ITX</a> 。、</p></li></ul></li></ul><h2 id="图形处理器（显卡GPU）"><a href="#图形处理器（显卡GPU）" class="headerlink" title="图形处理器（显卡GPU）"></a>图形处理器（显卡GPU）</h2><p>📌图形处理器使显卡减少对中央处理器（CPU）的依赖，并分担部分原本是由中央处理器所担当的工作，尤其是在进行三维绘图运算时，功效更加明显。</p><ul><li><p><strong>主要参数</strong>：</p><ul><li><strong>独立显卡</strong>：指独立显卡（或称专用显卡）内的RAM只会被该卡专用，而不是指显卡是否可从主板上独立移除。透过PCI Express、AGP或PCI等扩展槽界面与主板连接。</li><li><strong>集成绘图处理器</strong>：内置显示核心，是集成在主板或CPU上的绘图处理器，运作时会借用部分的系统存储器。</li><li><strong>输出接口</strong>：<ul><li><a href="https://zh.wikipedia.org/wiki/VGA%E7%AB%AF%E5%AD%90"><strong>VGA</strong></a>：<strong>视频图形阵列</strong>，是IBM的一个使用模拟信号的电脑显示标准，在1987年随IBM PS&#x2F;2系列计算机推出。VGA是大多数PC制造商所遵循的最后一个IBM图形标准，几乎1990年后的所有PC图形硬件都最低支持VGA。当用VGA来表示分辨率时，通常是指640×480。VGA端子（英语：Video Graphics Array (VGA) connector），其他的名称包括D-sub 15，或mini D15，是一种3排共15针的DE-15。VGA端子通常在电脑的显卡、显示器及其他设备。是用作发送模拟信号。</li><li><a href="https://zh.wikipedia.org/wiki/HDMI"><strong>HDMI</strong></a>：<strong>高清多媒体界面</strong>，是一种全数字化影像和声音发送接口，可以发送未压缩的音频及视频信号。HDMI可用于机顶盒、DVD播放机、个人电脑、电视游乐器、综合扩大机、数字音响与电视机等设备。HDMI可以同时发送音频和视频信号。音频和视频信号采用同一条线材的设计大大简化系统线路的安装难度。</li><li><a href="https://zh.wikipedia.org/wiki/DVI"><strong>DVI</strong></a>：数字视频接口，是一种视频接口标准，设计的目的是用来传输未经压缩的数字化影像。目前广泛应用于LCD、数字投影机等显示设备上。DVI接口可以发送未压缩的数字视频资料到显示设备。本规格部分兼容于HDMI标准。</li><li><a href="https://zh.wikipedia.org/wiki/DisplayPort"><strong>DP</strong></a>：DisplayPort（简称DP）是一个由PC及芯片制造商联盟开发，视频电子标准协会（VESA）标准化的数字式视频接口标准。该接口免认证、免授权金，主要用于视频源与显示器等设备的连接，并也支持音频、USB和其他形式的资料。透过主动或被动转接器，该接口可与传统接口（如HDMI和DVI）向下兼容。</li></ul></li><li><strong>核心频率</strong>：处理数据的速度</li><li><strong>流处理器单元数量</strong>：流处理单元是全新的全能渲染单元，由以前的顶点着色器和像素着色器结合而成的新一代显卡核心架构，是继Pixel Pipelines（像素管线）和Vertex Pipelines（顶点管线）之后新一代的显卡渲染技术指标。与GPU的核心架构有关，不同的架构没有可比性。</li></ul></li><li><p><strong>生产厂商</strong>：（三大厂N小厂）NVIDIA 和 AMD，Intel（基本只做核显）</p><ul><li><p><strong>NVIDIA</strong>：英伟达，是一家以设计和销售图形处理器为主的无厂半导体公司。</p><ul><li><p>产品生产线：</p><ul><li>GeForce<ul><li>RTX：带光追</li><li>GTX：普通独显</li><li>GT：低级显卡</li></ul></li><li>TiTan</li></ul></li><li><p><strong>GPU命名规则</strong>：N卡，GeForce为例</p></li></ul></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Zhoufenmianfan/images/main/202401112039483.png"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p><ul><li><p><strong>AMD</strong>：超威半导体公司</p><ul><li><p>Radeon：</p><ul><li>RX：对标RTX</li><li>R：对标GTX</li><li>HD：对标GT</li></ul></li><li><p><strong>GPU命名规则</strong>：</p></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/Zhoufenmianfan/images/main/202401112039550.png"  data-tag='post-image' loading="lazy" onerror='this.onerror=null;this.src="/img/404.jpg"'></p><h2 id="电源"><a href="#电源" class="headerlink" title="电源"></a>电源</h2><ul><li><strong>主要参数</strong>：目前一般的电源供应器大都为<strong>开关模式电源</strong><ul><li><strong>输入电压</strong>：输入电压自动适应家用所在地点市电参数，常用的ATX规格PC电源供应器，输入电压一般为 100V至 250V之间；</li><li><strong>输入交流电频率</strong>：50Hz 或 60Hz</li><li><strong>输出电压</strong>：输出 12V、5V及 3.3V三种稳定的直流电压</li><li><strong>额定功率标定</strong>：电源供应器的总额定输出功率(Watt)，是由从同一高频变压器上分出的各路电压通道的额定输出功率以及关键组件的参数（像是功率级FET或BJT&#x2F;GTR的最大电流容量)计算而得。</li><li><strong>转换效率</strong>：转换效率是指电源供应器能将输入电力转换成多少输出电力的百分比。举例来说, 如果转换效率只有50%，一个1000瓦的电力在转换后, 只有500瓦的电力可用, 而另外50% (500瓦)的电力则被转换成废热能,不但浪费原来的电力,更加重散热系统的负担。而更需努力运转以散除这些废热能的散热系统,又会耗损更多的电力。</li><li><strong>直流输出组</strong>：直流输出端的接口资源，可能有“ATX motherboard”、“12V only”、“12V only System monitoring”、“ATX12V”、“大4针”、“小4针”、“Auxiliary”辅助电源连接器、“SATA”15针电源连接器、“PCIe 6针”外挂辅助供电连接器、“PCIe 6+2针”外挂辅助供电连接器</li><li><strong>交流输入口</strong>：一个IEC 60320（C13&#x2F;C14）规范的连接器（插座与插头）用作市电输入。</li><li><strong>输出线模块化</strong>：模块化电源供应器（Modular PSU）提供可扩展的输出电线插座，以及可拔插的电线。一般传统非模块化电源供应器会为外设预留多组线缆供用家扩展电脑内组件，而暂时用不到的电线往往会占据机壳内的空间。因此，使用模块化电源供应器，电脑厂商以及用家可以因电脑内组件的需要来插装所需的电线，暂时用不到的则留空电源供应器的输出电线插座即可。</li><li><strong>使用寿命</strong>：电源供应器的使用寿命主要参考其平均无故障工作间隔（mean time between failures，MTBF），这个数值越高则代表该种设备的平均使用寿命更长更可靠。使用较好的电子组件，并且在不达到它们极限参数状态下工作、散热良好，降低组件损毁的几率，也可提高MTBF数值。</li><li><strong>认证</strong>：一般的安规认证标志（会因为销售地区不同而有不同的认证）有UL（UL 60950-1）、GS、TÜV&#x2F;cTUVus、NEMKO、SEMKO、DEMKO、FIMKO、CCC&#x2F;CUL、CSA、VDE、GOST R、BSMI以及EN60950-1:2006 + A11 + A1 + A12等。而一般的电磁干扰认证标志有FCC、CE标志以及C-Click。在欧洲以及印度贩售的电源供应器必须符合CE的标准并附带CE标志。另外，也有RoHS环保标志、80 PLUS转换效率标准认证等认证标志。</li></ul></li></ul><h2 id="总线与接口"><a href="#总线与接口" class="headerlink" title="总线与接口"></a>总线与接口</h2><ul><li><strong>主要参数</strong>：<ul><li><strong>宽度</strong>：可同时传输的资料数就称为宽度（width），以比特为单位，总线宽度愈大，传输性能就愈佳。</li><li><strong>总线带宽</strong>：总线带宽 &#x3D; 频率×宽度（Bytes&#x2F;sec），即单位时间内可以传输的总资料数。</li></ul></li><li><strong>分类</strong>：<ul><li><strong>数据总线</strong>（Data Bus）：在CPU与RAM之间来回传送需要处理或是需要储存的数据。</li><li><strong>地址总线</strong>（Address Bus）：用来指定在RAM（Random Access Memory）之中储存的数据的地址。</li><li><strong>控制总线</strong>（Control Bus）：将微处理器控制单元（Control Unit）的信号，传送到周边设备，一般常见的为USB Bus和1394 Bus。</li><li><strong>扩展总线</strong>（Expansion Bus）：可连接扩展槽和电脑。</li><li><strong>局部总线</strong>（Local Bus）：取代更高速数据传输的扩展总线。</li></ul></li><li><strong>内部总线</strong>：指的是系统内部的总线，这里只介绍和PC相关的总线<ul><li><strong>并发总线</strong>：<ul><li><a href="https://zh.wikipedia.org/wiki/%E5%B7%A5%E4%B8%9A%E6%A0%87%E5%87%86%E7%BB%93%E6%9E%84">ISA</a>：工业标准架构总线。</li><li><a href="https://zh.wikipedia.org/wiki/EISA">EISA</a>：扩展ISA</li><li><a href="https://zh.wikipedia.org/wiki/LPC%E5%8C%AF%E6%B5%81%E6%8E%92">LPC</a>：LPC总线</li><li><a href="https://zh.wikipedia.org/wiki/MCA">MCA</a>：微通道</li><li><a href="https://zh.wikipedia.org/wiki/PCI">PCI</a>：外设元件互连标准（个人电脑接口），是一种连接电脑主板和外部设备的总线标准。一般PCI设备可分为以下两种形式：<ul><li>直接内置于主板上的集成电路，在PCI规范中称作“嵌入设备”（planar device）；</li><li>安装在插槽上的扩展界面卡。</li></ul></li><li><a href="https://zh.wikipedia.org/wiki/VESA%E5%8C%AF%E6%B5%81%E6%8E%92">VLB</a>（VL-bus）：VESA本地总线</li></ul></li><li>串行总线：<ul><li><a href="https://zh.wikipedia.org/wiki/HyperTransport">HT</a>（LDT）：HyperTransport总线技术，简称“HT总线”，以前曾被称作“闪电数据传输”（Lightning Data Transport，LDT），是一种电脑处理器的互联技术。</li><li><a href="https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E9%80%9A%E9%81%93%E4%BA%92%E8%81%94">QPI</a>：快速通道互联；</li><li><a href="https://zh.wikipedia.org/wiki/%E7%9B%B4%E6%8E%A5%E5%AA%92%E9%AB%94%E4%BB%8B%E9%9D%A2">DMI</a>：直接媒体接口</li><li><a href="https://zh.wikipedia.org/wiki/I%C2%B2C">I²C</a>：集成电路之间，它其实是I²C Bus简称，所以中文应该叫集成电路总线；</li><li><a href="https://zh.wikipedia.org/wiki/PCI_Express">PCIe</a>（PCI-E）：是计算机总线的一个重要分支，它沿用既有的PCI编程概念及信号标准，并且构建了更加高速的串行通信系统标准。大部分新型的AMD或NVIDIA显卡都使用PCIe标准。NVIDIA在它新开发的SLI上采用PCIe的高速数据传输，这使得两块相同芯片组显卡可同时工作于一台电脑之上。AMD公司也基于PCIe开发一种两个GPU一同运作的技术，称为CrossFire。</li><li><a href="https://zh.wikipedia.org/wiki/USB">USB</a>：通用串行总线，是连接电脑与设备的一种序列总线标准，也是一种输入输出(I&#x2F;O) 连接端口的技术规范，广泛应用于个人电脑和移动设备等信息通信产品，并扩展至摄影器材、数字电视（机顶盒）、游戏机等其它相关领域。</li></ul></li></ul></li><li><strong>外部总线（I&#x2F;O总线，输入输出接口）</strong>：I&#x2F;O总线指缆线和连接器系统，用来传输I&#x2F;O路径技术指定的数据和控制信号，另外还包括一个总线终端电阻或电路，这个终端电阻用来减弱电缆上的信号反射干扰。<ul><li><strong>并发总线</strong>：<ul><li><a href="https://zh.wikipedia.org/wiki/%E9%AB%98%E6%8A%80%E8%A1%93%E9%85%8D%E7%BD%AE">ATA</a>：磁盘&#x2F;光盘驱动器总线。</li><li><a href="https://zh.wikipedia.org/wiki/PC%E5%8D%A1">PC卡</a>：前身为知名的<em>PCMCIA</em>，常用于笔记本电脑。</li><li><a href="https://zh.wikipedia.org/wiki/%E5%B0%8F%E5%9E%8B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%8E%A5%E5%8F%A3">SCSI</a>：小小型电脑系统接口，磁盘&#x2F;磁带总线。</li></ul></li><li><strong>串行总线</strong>：<ul><li><a href="https://zh.wikipedia.org/wiki/USB">USB</a></li><li><a href="https://zh.wikipedia.org/wiki/%E4%B8%B2%E5%88%97SCSI">SAS</a>：序列式SCSI</li><li><a href="https://zh.wikipedia.org/wiki/SATA">SATA</a>：串行磁盘&#x2F;光盘驱动器总线。</li><li><a href="https://zh.wikipedia.org/wiki/%E6%8E%A7%E5%88%B6%E5%99%A8%E5%8D%80%E5%9F%9F%E7%B6%B2%E8%B7%AF">控制器局域网</a></li><li><a href="https://zh.wikipedia.org/wiki/EIA-485">EIA-485</a></li><li><a href="https://zh.wikipedia.org/wiki/IEEE_1394">IEEE 1394</a>：火线</li><li><a href="https://zh.wikipedia.org/wiki/Thunderbolt">Thunderbolt</a></li><li><a href="https://zh.wikipedia.org/wiki/InfiniBand">InfiniBand</a>（在目前<a href="https://zh.wikipedia.org/wiki/%E8%B6%85%E7%B4%9A%E9%9B%BB%E8%85%A6">超级电脑</a>排名<a href="https://zh.wikipedia.org/wiki/TOP500">TOP500</a>之中常见）</li></ul></li></ul></li><li><strong>接口</strong>：<ul><li><a href="https://zh.wikipedia.org/wiki/AGP">AGP</a>：加速图形接口，是电脑主板上的一种高速点对点传输通道，供显卡使用，主要应用在三维电脑图形的加速上。</li><li><a href="https://zh.wiktionary.org/wiki/IDE">IDE</a>：（电脑）硬盘、光驱的一种较常用的接口标准，通常主板上会有 IDE 接口，相对应的技术是 SCSI，S-ATA</li><li><a href="https://zh.wikipedia.org/wiki/M.2">M.2</a>：是计算机内部扩展卡及相关连接器的外观尺寸与针脚的电气接口规范。采用了全新的物理布局和连接器，以取代PCI Express(PCIE)及mSATA接口标准。</li><li><strong>固态硬盘接口</strong>：当下主流的固态硬盘接口有M.2、U.2、PCIe、SATA、SATA Express、SAS等。M.2和U.2可选PCIe接口[14]。NVMe协议是目前最高效的PCIe SSD协议标准。</li><li><strong>显卡接口</strong>：大部分新型的AMD或NVIDIA显卡都使用PCIe标准。NVIDIA在它新开发的SLI上采用PCIe的高速数据传输，这使得两块相同芯片组显卡可同时工作于一台电脑之上。AMD公司也基于PCIe开发一种两个GPU一同运作的技术，称为CrossFire。</li></ul></li></ul><h2 id="机箱"><a href="#机箱" class="headerlink" title="机箱"></a>机箱</h2><ul><li><p><strong>主要参数</strong>：</p><ul><li><p><strong>形状规格</strong>：绝大多数电脑机箱的外形都呈长方体，分为卧式和立式两种。按照大小可以分为全塔机箱、<strong>中塔机箱</strong>（主流PC组装）、小机箱、ITXmini等。</p></li><li><p><strong>风道设计</strong>：最合适的风道设计是底下进风，上面出风的散热设计；</p></li></ul></li></ul>]]></content>
    
    
    <summary type="html">为什么市场上有这么多种PC组件设备？</summary>
    
    
    
    <category term="Tech" scheme="https://zhoufenmianfan.github.io/categories/Tech/"/>
    
    
    <category term="Computer" scheme="https://zhoufenmianfan.github.io/tags/Computer/"/>
    
  </entry>
  
  <entry>
    <title>想要：和小伙伴一起玩《饥荒》</title>
    <link href="https://zhoufenmianfan.github.io/2024/01/06/Linux%E9%A5%A5%E8%8D%92%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/"/>
    <id>https://zhoufenmianfan.github.io/2024/01/06/Linux%E9%A5%A5%E8%8D%92%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%90%AD%E5%BB%BA%E6%95%99%E7%A8%8B/</id>
    <published>2024-01-06T10:14:52.000Z</published>
    <updated>2024-01-09T06:27:18.549Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装SteamCMD"><a href="#安装SteamCMD" class="headerlink" title="安装SteamCMD"></a>安装SteamCMD</h2><ul><li><p><strong>云服务器</strong>：可以使用任意远程终端工具连接到自己的云服务器，这里用Tabby做演示；</p></li><li><p><strong>创建Linux用户</strong>：由于在root用户下安装会有一定的安全风险，所以建议创建一个新的用户，在另一个用户下安装；</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo useradd -m steam #创建名为steam的用户</span><br><span class="line">sudo passwd steam #为用户steam设置密码</span><br><span class="line">sudo -u steam -s #进入steam用户</span><br></pre></td></tr></table></figure><ul><li><strong>安装SteamCMD</strong>：进入指定的一个目录，例如&#x2F;home&#x2F;steam，这个就是作为steam用户的根目录，不同的Linux系统用不同的安装指令；</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install steamcmd #Ubuntu&amp;Debian</span><br><span class="line">yum install steamcmd # CentOS&amp;RedHat</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">如果不能正确下载请注意是否是对应的包管理器版本过低等问题</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">如果出现权限不足的问题，那么就回到root用户进行下载</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">也可以下载tar包再解压的办法（实际这个比较方便）</span></span><br><span class="line">wget https://steamcdn-a.akamaihd.net/client/installer/steamcmd_linux.tar.gz  </span><br><span class="line">tar -zxvf steamcmd_linux.tar.gz</span><br></pre></td></tr></table></figure><ul><li><strong>运行SteamCMD</strong>：出现图所示Steam&gt;即为成功；</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install glibc.i686 libstdc++.i686 #首先要升级运行库，RedHat/CentOS (x86-64)</span><br><span class="line">./steamcmd.sh #在解压出steamcmd_tar的目录下运行</span><br></pre></td></tr></table></figure><h2 id="饥荒服务端配置"><a href="#饥荒服务端配置" class="headerlink" title="饥荒服务端配置"></a>饥荒服务端配置</h2><ul><li>文件路径配置：创建一个用于保存饥荒服务器端的文件夹</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">force_install_dir /home/dstserver </span><br></pre></td></tr></table></figure><ul><li>下载饥荒：需要先匿名登录steam，或者使用自己的用户账户&amp;密码登录</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">login anonymous</span><br><span class="line">app_update 343050 validate #下载or更新饥荒（如果饥荒客户端有更新，同样服务端也需要更新，否则搜不到自己的服务器存档）</span><br><span class="line">quit #下载更新完成后退出SteamCMD</span><br></pre></td></tr></table></figure><ul><li>启动服务端：在服务端路径运行一次即可生成对应的World存档（方便后续直接通过覆盖配置文件的方式来获得想要的配置的存档）；</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /home/dstserver/bin</span><br><span class="line">./master_start.sh #启动主世界，Ctrl+C关闭</span><br><span class="line">./cave_start.sh #启动洞穴世界，Ctrl+C关闭</span><br></pre></td></tr></table></figure><ul><li>覆盖存档：需要在本地创建一个世界，注意把自己想要的Mod（服务端Mod）开启（这样才能自动创建自己需要的服务端Mod的配置文件，当然后续也可以自己主动修改配置文件来重新添加服务端Mod）；将存档的所有文件覆盖掉服务器上的存档文件；</li><li>获取Token：由于需要绑定服务器信息，因此需要获取服务器Token，以确定这个服务器的地址；同样在饥荒启动首页点击【账户信息】跳转至Klei页面，点击查看我的游戏，找到右上角Don’t Strave Together Servers，创建一个token，集群名字任意（token是一串pds-开头的字符串）；复制token保存为一个cluster_token.txt文件中；</li></ul><h2 id="Mod配置"><a href="#Mod配置" class="headerlink" title="Mod配置"></a>Mod配置</h2><ul><li>配置文件路径：如果想在原有的基础上继续添加mod就需要更改配置文件，一共有两个地方的配置文件，一个是存档文件夹下的modoverrides.lua文件（注意Master和Caves下各有一个同样的文件），另一个是服务器配置中的dedicated_server_mods_setup.lua文件；</li><li>Mod编号：每一个创意工坊中的Mod都有唯一的APPID，可以通过分享的方式在链接中查看；</li><li>修改配置文件：</li></ul><h2 id="启动游戏"><a href="#启动游戏" class="headerlink" title="启动游戏"></a>启动游戏</h2><ul><li>Screen命令：由于游戏需要运行两个程序，而一般需要后台运行，因此可以使用linux的窗口screen功能，基本指令如下；</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">screen -S [NAME] #创建一个名字为[NAME]的窗口</span><br><span class="line">screen -ls #列出窗口的id.[NAME]</span><br><span class="line">screen -r [id] #如果一个窗口是（Deattached）状态，可以重连</span><br><span class="line">screen -d [id] #退出一个窗口</span><br><span class="line">exit #退出一个窗口并关闭此窗口（相应的进程也会关闭）</span><br></pre></td></tr></table></figure><ul><li>启动游戏：分布在指定路径下创建两个名字为master和cave的窗口；然后在对应的窗口运行游戏的两个进程即可；游戏正常启动会看见有类似Sim Pause的字符</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd dstsever/bin</span><br><span class="line">screen -S master</span><br><span class="line">./master_start.sh</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可以直接退出上述的终端，不要输入<span class="built_in">exit</span>，窗口就不会关闭（只会失去连接），进程也不会结束</span></span><br><span class="line">cd dstsever/bin</span><br><span class="line">screen -S cave</span><br><span class="line">./cave_start.sh</span><br></pre></td></tr></table></figure><ul><li>加入服务器：直接在浏览游戏中搜索房间名字即可；</li></ul>]]></content>
    
    
    <summary type="html">使用SteamCMD平台上搭建饥荒服务器</summary>
    
    
    
    <category term="Tech" scheme="https://zhoufenmianfan.github.io/categories/Tech/"/>
    
    
    <category term="SteamCMD" scheme="https://zhoufenmianfan.github.io/tags/SteamCMD/"/>
    
    <category term="Linux" scheme="https://zhoufenmianfan.github.io/tags/Linux/"/>
    
    <category term="Game" scheme="https://zhoufenmianfan.github.io/tags/Game/"/>
    
  </entry>
  
  <entry>
    <title>懒得：手动更新《饥荒》服务器上的插件</title>
    <link href="https://zhoufenmianfan.github.io/2024/01/06/%E9%A5%A5%E8%8D%92%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0%E6%95%99%E7%A8%8B/"/>
    <id>https://zhoufenmianfan.github.io/2024/01/06/%E9%A5%A5%E8%8D%92%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%87%AA%E5%8A%A8%E6%9B%B4%E6%96%B0%E6%95%99%E7%A8%8B/</id>
    <published>2024-01-06T10:00:54.000Z</published>
    <updated>2024-01-09T06:28:04.665Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文件树结构"><a href="#文件树结构" class="headerlink" title="文件树结构"></a>文件树结构</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">注意以下就是绝对路径/steam</span></span><br><span class="line">└── steam #（用户）根目录</span><br><span class="line">├── common #饥荒游戏存档服务器相关目录</span><br><span class="line">│ ├── backup #备份文件夹</span><br><span class="line">│ ├── dstsave #存档目录</span><br><span class="line">│ └── dstserver #服务器目录</span><br><span class="line">├── cron_update_starve.sh #定时更新程序</span><br><span class="line">├── steamcmd #steamcmd服务目录</span><br><span class="line">│ ├── linux32</span><br><span class="line">│ ├── linux64</span><br><span class="line">│ ├── package</span><br><span class="line">│ ├── public</span><br><span class="line">│ ├── siteserverui</span><br><span class="line">│ ├── steam</span><br><span class="line">│ ├── steamcmd_linux.tar.gz</span><br><span class="line">│ └── steamcmd.sh #steamcmd启动脚本</span><br><span class="line">├── update_starve.cmd #更新饥荒服务端命令库</span><br><span class="line">└── update_starve.sh #更新饥荒服务端脚本</span><br></pre></td></tr></table></figure><h2 id="定时调度"><a href="#定时调度" class="headerlink" title="定时调度"></a>定时调度</h2><p>📌如果想要服务器定期执行一些列动作，就需要一个定时器来指定需要执行的程序脚本</p><ul><li><strong>crontab</strong>：可以制定一个进程表</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">[root@VM-8-6-centos]$ </span><span class="language-bash">crontab -e <span class="comment">#编辑当前用户的时程表</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">VI中编辑</span></span><br><span class="line">0 2 * * * /steam/cron_update_starve.sh #每天的凌晨2：00执行一次.sh</span><br></pre></td></tr></table></figure><ul><li>定时调度脚本：cron_update_starve.sh中需要装载执行一次饥荒服务器更新时需要的所有动作（指令集）</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">第一行的<span class="comment">#！符号表示用于指定shell脚本的解释器是用/bin/bash</span></span></span><br><span class="line">set -e #指定shell脚本的工作模式</span><br><span class="line">/steam/common/dstserver/bin/stop.sh #第一步：执行停机脚本，关闭正在运行的饥荒服务端，避免数据丢失</span><br><span class="line">sleep 5 #休眠5分钟</span><br><span class="line">/steam/update_starve.sh #第二步：执行饥荒服务端的更新脚本</span><br><span class="line">/steam/common/dstserver/bin/start.sh #第三步：执行饥荒服务端的启动脚本</span><br></pre></td></tr></table></figure><h2 id="饥荒服务端更新"><a href="#饥荒服务端更新" class="headerlink" title="饥荒服务端更新"></a>饥荒服务端更新</h2><ul><li>停机脚本：stop.sh 关闭正在运行的饥荒服务端，避免数据丢失；</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">pids=$(ps aux | grep dontstarve | awk -v OFS=&#x27;,&#x27; &#x27;&#123;print $2,$11&#125;&#x27;) #获取进程的PID</span><br><span class="line">array=($&#123;pids// / &#125;)</span><br><span class="line">for var in $&#123;array[@]&#125;</span><br><span class="line">do</span><br><span class="line">    item=($&#123;var//,/ &#125;)</span><br><span class="line">    result=`echo $&#123;item[1]&#125; | grep dontstarve`</span><br><span class="line">    if [[ &quot;$result&quot; != &quot;&quot; ]]</span><br><span class="line">    then</span><br><span class="line">          rs=$(kill -9 $&#123;item[0]&#125;)</span><br><span class="line">    fi</span><br><span class="line">done</span><br></pre></td></tr></table></figure><ul><li>更新脚本：update_starve.sh 更新饥荒服务端；</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">/steam/steamcmd/steamcmd.sh &lt; /steam/update_starve.cmd #将.cmd指令集中的指令重定向到使用SteamCMD命令行打开后执行</span><br></pre></td></tr></table></figure><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">force_install_dir /steam/common/dstserver <span class="comment">#SteamCMD命令行中强制安装在指定目录指令</span></span><br><span class="line">login anonymous <span class="comment">#匿名登录</span></span><br><span class="line">app_update <span class="number">343050</span> validate <span class="comment">#更新饥荒（在steam中代码为343050）</span></span><br><span class="line">quit <span class="comment">#退出SteamCMD</span></span><br></pre></td></tr></table></figure><ul><li>启动脚本：start.sh 重新启动饥荒服务端；</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">set -e</span><br><span class="line">SCRIPT_DIR=&quot;$( cd &quot;$( dirname &quot;$&#123;BASH_SOURCE[0]&#125;&quot; )&quot; &amp;&amp; pwd )&quot;</span><br><span class="line">cd $SCRIPT_DIR</span><br><span class="line">nohup ./start_master.sh  &gt;/dev/null 2&gt;&amp;1 &amp;</span><br><span class="line">nohup ./start_cave.sh    &gt;/dev/null 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">为饥荒服务器添加自动更新服务端插件脚本</summary>
    
    
    
    <category term="Tech" scheme="https://zhoufenmianfan.github.io/categories/Tech/"/>
    
    
    <category term="SteamCMD" scheme="https://zhoufenmianfan.github.io/tags/SteamCMD/"/>
    
    <category term="Linux" scheme="https://zhoufenmianfan.github.io/tags/Linux/"/>
    
    <category term="Game" scheme="https://zhoufenmianfan.github.io/tags/Game/"/>
    
  </entry>
  
</feed>
